/***
* Утилиты:
*/

/**
* W - width:
* `W` - утилита, которая управляет шириной компонента.
*
*		@example
*		div.W4c
*			.test-content
*				h3 Просто текст в контейнере
*				p
*					Aenean euismod elementum nisi, quis eleifend quam adipiscing vitae proin sagittis, nisl. Suscipit tellus mauris a diam maecenas sed enim ut sem viverra aliquet eget sit amet tellus cras adipiscing enim eu turpis egestas pretium aenean pharetra, magna ac placerat.
*/

/**
* Ml - margin left:
* `Ml` задает компонентам отступ слева.
*
*		@example
*		.Ml3c.test-content
*			h3 Контейнер с отступом
*			p Aenean euismod elementum nisi, quis eleifend quam adipiscing vitae proin sagittis, nisl. Suscipit tellus mauris a diam maecenas sed enim ut sem viverra aliquet eget sit amet tellus cras adipiscing enim eu turpis egestas pretium aenean pharetra, magna ac placerat.
*/

/**
* Rj - row justify:
* Утилита распределяющая колонки по горизонтали.
*
*		@example
*		.row.Rj-c
*			.row__col.W5c: .test-content Текст в колонке
*			.row__col.W3c: .test-content 3/12
*/

/**
* Rai - row align items:
* Утилита, которая выравнивает колонки по вертикали.
*
*		@example
*		.row.Rai-fe
*			.row__col.W4c.test-content
*				h4 Текст в колонке
*				p Et molestie ac, feugiat sed lectus
*				p Текст в колонке
*			- for(var i = 0; i < 3; i++)
*				.row__col.W2c.test-content
*					p Текст в колонке
*
*/

.W-card {
	max-width: $mlu-row-card-default-width;
}

.Maw100p {
	max-width: 100%;
}

.W-a {
	width: auto;
}

.W1c {
	width: 50% - ($mlu-grid-gutter-fallback * 2);
	width: calc(50% - #{$mlu-gtr-sm * 2});
}

.W50p {
	width: 50%;
}

// Generate grid utilities W and Ml on breakpoints
@each $key, $value in $mlu-grid-cols {
	$col-gutter: mlu-grid-gutter($key);
	$prev-col-gutter: 0;

	@if index($mlu-grid-cols, ($key $value)) > 1 {
		$prev-col-gutter: mlu-grid-gutter(mlu-breakpoint-prev-name($key));
	}

	@include mlu-bpm($key) {
		// Repeat generation utility with new gutter if it changed on breakpoint
		@if $col-gutter != $prev-col-gutter and $key != $mlu-bp-sm {
			.W1c {
				width: calc(50% - #{$col-gutter * 2});
			}
		}

		.W-a_#{$key} {
			width: auto;
		}

		// Pass through the map of gutters to check for
		// gutter differences at the current breakpoint and on breakpoint
		// on which we want to generate
		@each $gtr-key, $gtr-value in $mlu-grid-gutters {
			$cols-count: mlu-grid-cols-count($gtr-key);

			@for $i from 1 through mlu-grid-cols-count($key) {
				$col-width: mlu-decimal-floor($i / $cols-count * 100%, 3);

				// Repeat generation utility with new gutter if it changed on breakpoint.
				// It need for utilities for smaller breakpoints correct work
				// on larger breakpoints with changed gutter
				@if $i <= $cols-count and
					($gtr-key == $key or ($gtr-value < $col-gutter and $col-gutter != $prev-col-gutter)) {
					.W#{$i}c_#{$gtr-key} {
						// Generation calc() fallback if flag turn on or
						// current breakpoint is $mlu-bp-sm
						@if $MLU-FLAG-CALC-FALLBACK or $gtr-key == $mlu-bp-sm {
							width: mlu-decimal-floor($col-width, 2) - ($mlu-grid-gutter-fallback * 2);
						}

						width: calc(#{$col-width} - #{$col-gutter * 2});
					}

					.W#{$i}s_#{$gtr-key} {
						width: $col-width;
					}

					// Offsets start generate from $mlu-bp-md and if offset flag turn on.
					// '$i < mlu-grid-cols-count($gtr-key) - 1' because
					// offset like 'Ml11c' makes no sense
					@if $MLU-FLAG-COL-OFFSET and
						mlu-breakpoint($gtr-key) > mlu-breakpoint($mlu-bp-sm) and
						$i < mlu-grid-cols-count($gtr-key) - 1 {
						.Ml#{$i}s_#{$gtr-key} {
							margin-left: $col-width;
						}

						.Ml#{$i}c_#{$gtr-key} {
							@if $MLU-FLAG-CALC-FALLBACK {
								margin-left: mlu-decimal-floor($col-width, 2) + $mlu-grid-gutter-fallback;
							}

							margin-left: calc(#{$col-width} + #{$col-gutter});
						}
					}
				}
			}
		}

		@if $MLU-FLAG-COL-OFFSET and mlu-breakpoint($key) > mlu-breakpoint($mlu-bp-md) {
			.Ml0c_#{$key} {
				margin-left: mlu-grid-gutter($key);
			}

			.Ml0_#{$key} {
				margin-left: 0;
			}
		}
	}
}
