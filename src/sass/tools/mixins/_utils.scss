@use "sass:meta";
@use "sass:list";
@use "sass:map";
@use "sass:math";
@use "sass:string";

@use "forward-tools" as mlu;
@use "general" as mgen;
@use "grid" as mgs;

$-su-rem: mlu.px2rem(mlu.$su);
$-gtr-sm-rem: mlu.px2rem(mlu.$gtr-sm);

/*
Utilities

Mixins for creating utilities and working with them.

Styleguide: sass-tools.mixins.utils
*/

// bp-all
//
// Generates the CSS rule on breakpoints, adding the name of the breakpoint to the selector, inside the corresponding media query.
//
// ```scss
//@include bp-all(".Bdw1") {
//		border-width: 1px;
//}
// ```
// CSS
// ```css
//.Bdw1 {
//		border-width: 1px;
//}
//
//@media (min-width: 520px) {
//		.Bdw1_sm {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 760px) {
//		.Bdw1_md {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 960px) {
//		.Bdw1_lg {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 1168px) {
//		.Bdw1_xl {
//			border-width: 1px;
//		}
//}
// ```
// You can also use mixin inside the rule. This will work as well as the example above:
// ```scss
//.Bdw1 {
//		@include bp-all() {
//			border-width: 1px;
//		}
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $xs = 1 - any type flag. If equal to 1, then the rule will first be generated outside of breakpoints(in `xs`).
//
// Styleguide: sass-tools.mixins.utils.bp_all

@mixin bp-all($selector: &, $xs: 1) {
	@if not $selector {
		@error "'$selector' argument must not be null.";
	}

	@at-root {
		@if $xs == 1 {
			#{$selector} {
				@content;
			}
		}

		@each $key, $value in mlu.$breakpoints {
			@include mgen.bpm($key) {
				#{$selector}_#{$key} {
					@content;
				}
			}
		}
	}
}

// mk-state
//
// Generates values for utilities in various [states](section-concepts.html#kssref-concepts-utility-states). Names and values of states are set in the [settings](#kssref-sass-tools-settings-utils-states). Usually this mixin is not used separately because it is called inside [mk-util](#kssref-sass-tools-mixins-mk_util).
//
// ```scss
//@include mk-state(".Bgc-mn0", ("h")) {
//		background-color: #60f;
//}
// ```
// CSS
// ```css
//.Bgc-mn0 {
//		background-color: #60f;
//}
//
//.h_Bgc-mn0:hover {
//		background-color: #60f;
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $states = map-keys(settings.$util-states) -  list of state names to be generated.
// $no-state = 1 - number flag. If equal to 1, then a value without state will be generated as in the example above.
//
// Styleguide: sass-tools.mixins.utils.mk_state

@mixin mk-state($selector: &, $states: map.keys(mlu.$util-states), $no-state: 1) {
	@if not $selector {
		@error "'$selector' argument must not be null.";
	}

	@at-root {
		@if $no-state == 1 {
			#{$selector} {
				@content;
			}
		}

		$selector: mlu.check-class($selector, 1);

		@each $key, $value in mlu.$util-states {
			@if list.index($states, $key) {
				$prefix: "." + $key;

				@if meta.type-of($value) == "string" {
					#{$prefix}_#{$selector}:#{$value} {
						@content;
					}
				} @else if meta.type-of($value) == "list" {
					$multi-selector: ();

					@each $item in $value {
						$multi-selector: list.append($multi-selector, $prefix + "_" + $selector + ":" + $item, comma);
					}

					#{$multi-selector} {
						@content;
					}
				} @else {
					#{$prefix}_#{$selector} {
						@content;
					}
				}
			}
		}
	}
}

// mk-util
//
// Ð¡reates utilities based on a map in which the *keys* are the values of the utilities, and the *values* are the values of the CSS properties.
//
// Utility values are set according to the utility [naming rules](section-concepts.html#kssref-concepts-utility). They can be a string (including empty) or a number. Also, the value can indicate the breakpoint on which it should work - `"tb_lg"`. Even if the breakpoint is passed as a parameter when this mixin is called, then the data about breakpoints from the values map will be more priority. In addition to a specific breakpoint, 2 special values are valid:
// * `bp` - create a value only on breakpoints:	`"r_bp"`, "4gg_bp"
// * `all` - create a normal value and on breakpoints: `"ib_all"`, `"_all"`.
//
// Values for CSS properties can be any CSS values, as well as numbers with `gg` and `su` units. Values with  `gg` units are created using the [mk-gtr](#kssref-sass-tools-mixins-mk_gtr) mixin.
//
// ```scss
//$Bgc-map: (
//		"f": #fff,
//		"mn0_lg": #60f,
//		"mn1": #c05,
//);
//
//@include mk-util("Bgc", $Bgc-map);
// ```
// CSS
// ```css
//.Bgc-f {
//		background-color: #fff;
//}
//
//.Bgc-mn1 {
//		background-color: #c05;
//}
//
//@media (min-width: 960px) {
//		.Bgc-mn0_lg {
//			background-color: #60f;
//		}
//}
// ```
//
// $name - the name of the utility. It can be specified as a CSS class (with a dot) or just a `string`.
// $map - map with utilities names values and CSS properties values.
// $bp = false - breakpoint on which utility values will be generated. Can be any breakpoint from the settings or a special value: `bp` and `all`.
// $states = false - list of state names. For each value of the utility, all states from this list will be generated. Info about states see [here](section-concepts.html#kssref-concepts-utility-states).
// $prop = false - CSS property name.
//
// Styleguide: sass-tools.mixins.utils.mk_util

@mixin mk-util($name, $map, $bp: null, $states: null, $prop: null) {
	$util-name: mlu.check-class($name, 1);
	$prop: if($prop, $prop, mlu.util-prop($util-name));

	@if list.index(mlu.$utils-directed, $util-name) {
		$util-name: if($prop, $util-name, null);
		$utils-data-list: mlu.parse-util-directions($map, $util-name);
		$utils-directions: map.keys(list.nth($utils-data-list, 1));
		$utils-props: map.values(list.nth($utils-data-list, 1));
		$utils-map: list.nth($utils-data-list, 2);

		@each $key, $value in $utils-map {
			$util-index: list.index($utils-map, ($key $value));

			@include -generate-util(
				$key,
				$value,
				$bp,
				$states,
				list.nth($utils-props, $util-index),
				list.nth($utils-directions, $util-index)
			);
		}
	} @else {
		@include -generate-util($name, $map, $bp, $states, $prop);
	}
}

// Private mixin that generate utilities CSS.

@mixin -generate-util($name, $map, $bp: null, $states: null, $prop: null, $direct: null) {
	$name: mlu.check-class($name);

	@each $key, $value in $map {
		$util-val-map: mlu.parse-util($key);
		$bp-name: map.get($util-val-map, "mq");
		$bp-name: if($bp-name, $bp-name, $bp);
		$selector: $name + map.get($util-val-map, "value");

		@if $bp-name == "all" or $bp-name == "bp" {
			@include bp-all($selector, if($bp-name == "all", 1, 0)) {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $value);
				}
			}
		} @else if $bp-name {
			@include mgen.bpm($bp-name) {
				#{$selector}_#{$bp-name} {
					@include mk-state(&, $states, if($states, 0, 1)) {
						@include -check-util-direction($direct, $prop, $value);
					}
				}
			}
		} @else {
			#{$selector} {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $value);
				}
			}
		}
	}
}

// Private mixin that parses combined directions and identifies positioning utilities.

@mixin -check-util-direction($dir, $prop, $value) {
	@if $dir == "x" {
		$prop: if($prop, $prop + "-", "");
		@include -parse-unit($prop + "right", $value, "r");
		@include -parse-unit($prop + "left", $value, "l");
	} @else if $dir == "y" {
		$prop: if($prop, $prop + "-", "");
		@include -parse-unit($prop + "top", $value, "t");
		@include -parse-unit($prop + "bottom", $value, "b");
	} @else if $dir == "all" {
		$prop: if($prop, $prop + "-", "");
		@each $item in map.values(mlu.$main-directions) {
			@include -parse-unit($prop + $item, $value, string.slice($item, 1, 1));
		}
	} @else {
		@include -parse-unit($prop, $value, $dir);
	}
}

// Private mixin that parses custom units based on directions.

@mixin -parse-unit($prop, $value, $dir) {
	$coef-val: mlu.str2n($value + "");

	@if meta.type-of($value) == "number" and math.unit($value) == "gg" {
		$tmp-val: if($dir == "t" or $dir == "b", $-gtr-sm-rem, 1);
		$dash-pos: string.index($prop, "-");

		@if $dash-pos and $dir != "xy" {
			$prop: string.slice($prop, 1, $dash-pos - 1);
		} @else if $dir != "xy" {
			$dir: "xy";
		}

		@include mgs.mk-gtr($tmp-val, $type: $prop, $direct: $dir, $coef: $coef-val);
	} @else if meta.type-of($value) == "number" and math.unit($value) == "su" {
		@if $dir == "xy" {
			@include mgs.mk-gtr-xy($prop, mlu.$su * $coef-val, $-su-rem * $coef-val);
		} @else {
			$tmp-val: if($dir == "t" or $dir == "b", $-su-rem, mlu.$su);
			#{$prop}: $tmp-val * $coef-val;
		}
	} @else {
		#{$prop}: $value;
	}
}
