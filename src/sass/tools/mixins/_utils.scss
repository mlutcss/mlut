@use 'sass:meta';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';
@use 'sass:selector';

@use 'forward-tools' as mlu;
@use '../functions/general' as mgf;
@use 'general' as mgen;
@use 'grid' as mgs;

$-su-rem: mlu.px2rem(mlu.$su);
$-gtr-sm-rem: mlu.px2rem(mlu.$gtr-sm);

$-utils-directed: map.get(mlu.$utils-config, 'directed');

/*
Utilities

Mixins for creating utilities and working with them.

Styleguide: sass-tools.mixins.utils
*/

// bp-all
//
// Generates the CSS rule on breakpoints, adding the name of the breakpoint to the selector, inside the corresponding media query.
//
// ```scss
//@include bp-all('.Bdw1') {
//		border-width: 1px;
//}
// ```
// CSS
// ```css
//.Bdw1 {
//		border-width: 1px;
//}
//
//@media (min-width: 520px) {
//		.Bdw1_sm {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 760px) {
//		.Bdw1_md {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 960px) {
//		.Bdw1_lg {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 1168px) {
//		.Bdw1_xl {
//			border-width: 1px;
//		}
//}
// ```
// You can also use mixin inside the rule. This will work as well as the example above:
// ```scss
//.Bdw1 {
//		@include bp-all() {
//			border-width: 1px;
//		}
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $xs = 1 - any type flag. If equal to 1, then the rule will first be generated outside of breakpoints(in `xs`).
//
// Styleguide: sass-tools.mixins.utils.bp_all

@mixin bp-all($selector: &, $xs: 1) {
	@if not $selector {
		@error '`$selector` argument must not be null.';
	}

	@at-root {
		@if $xs == 1 {
			#{$selector} {
				@content;
			}
		}

		@each $key, $value in mlu.$breakpoints {
			@include mgen.bpm($key) {
				#{$selector}_#{$key} {
					@content;
				}
			}
		}
	}
}

// mk-state
//
// Generates values for utilities in various [states](section-concepts.html#kssref-concepts-utility-states). Names and values of states are set in the [settings](#kssref-sass-tools-settings-utils-states). Usually this mixin is not used separately because it is called inside [mk-util](#kssref-sass-tools-mixins-mk_util).
//
// ```scss
//@include mk-state('.Bgc-mn0', ('h')) {
//		background-color: #60f;
//}
// ```
// CSS
// ```css
//.Bgc-mn0 {
//		background-color: #60f;
//}
//
//.h_Bgc-mn0:hover {
//		background-color: #60f;
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $states = map-keys(settings.$utils-states) -  list of state names to be generated.
// $no-state = 1 - number flag. If equal to 1, then a value without state will be generated as in the example above.
//
// Styleguide: sass-tools.mixins.utils.mk_state

@mixin mk-state($selector: &, $states: map.keys(mlu.$utils-states), $no-state: 1) {
	@if not $selector {
		@error '`$selector` argument must not be null.';
	}

	@at-root {
		@if $no-state == 1 {
			#{$selector} {
				@content;
			}
		}

		$selector: mlu.check-class($selector, 1);

		@each $key, $value in mlu.$utils-states {
			@if list.index($states, $key) {
				$prefix: '.' + $key;

				@if meta.type-of($value) == 'string' {
					#{$prefix}_#{$selector}:#{$value} {
						@content;
					}
				} @else if meta.type-of($value) == 'list' {
					$multi-selector: ();

					@each $item in $value {
						$multi-selector: list.append($multi-selector, $prefix + '_' + $selector + ':' + $item, comma);
					}

					#{$multi-selector} {
						@content;
					}
				} @else {
					#{$prefix}_#{$selector} {
						@content;
					}
				}
			}
		}
	}
}

@mixin new-mk-state(
	$post,
	$pre: null,
	$no-state: true,
	$selector: &,
	$this-util: null
) {
	@if not $selector {
		@error '$selector argument must not be null.';
	}

	$selector: mlu.check-class($selector);
	$final-selector-list: ();
	$pre-comb-list: $selector;

	@at-root {
		@if $no-state {
			#{$selector} {
				@content;
			}
		}

		@if $pre {
			$pre-comb-list: ();
			$pre-states: mgf.str-split($pre, mlu.$states-cmb);
			$separate-states: list.nth($pre-states, 1);

			@if $separate-states != '' {
				$final-selector-list: -convert-states($separate-states, $selector, $this-util);
			}

			@if list.length($pre-states) > 1 {
				$pre-comb-list: -convert-states(list.nth($pre-states, 2), $selector, $this-util);
			}
		}

		@if $post {
			$post-states: mgf.str-split($post, mlu.$states-cmb);
			$separate-states: list.nth($post-states, 1);

			@if $separate-states != '' {
				$final-selector-list: list.join(
					$final-selector-list,
					-convert-states($separate-states, $selector, $this-util, 'post')
				);
			}

			@if list.length($post-states) > 1 {
				@each $pre-item in $pre-comb-list {
					$final-selector-list: list.join(
						$final-selector-list,
						-convert-states(list.nth($post-states, 2), $pre-item, $this-util, 'post')
					);
				}
			}
		}

		@each $item in $final-selector-list {
			#{$item} {
				@content;
			}
		}
	}
}

@function -pre-state-selector($list, $selector, $this: null) {
	$result: ();
	$selector: mlu.check-class($selector, 1);

	@each $item in $list {
		$selector-list: '';

		@each $part in mgf.str-split(
			mlu.convert-util-states($item, $this, true), ','
		) {
			$selector-list: $selector-list + '#{$part}.#{mlu.str-escape($item + mlu.$tUCm)}#{$selector},';
		}

		$result: list.append($result, string.slice($selector-list, 1, -2));
	}

	@return $result;
}

@function -post-state-selector($list, $selector, $this: null) {
	$result: ();

	@each $item in $list {
		$util-selector: selector.append($selector, mlu.str-escape(mlu.$tUCm + $item));
		$state-selector: mgf.str-replace-all(
			mlu.convert-util-states($item, $this), mlu.str-escape(mlu.$tSTucv), $util-selector
		);

		$result: list.append(
			$result,
			selector.nest(
				$util-selector,
				$state-selector
			)
		);
	}

	@return $result;
}

@function -convert-states($item, $selector, $this: null, $type: 'pre') {
	$result: mgf.str-split(mgf.str-trim($item), ' ');

	@each $key, $value in map.get(mlu.$utils-config, 'states', 'keywords') {
		@if meta.type-of($value) == 'string' {
			$value: map.keys(map.get(mlu.$utils-config, 'states', $value));
		}

		$result: mlu.replace-keyword($result, $key, $value);
	}

	@return meta.call(
		meta.get-function('-#{$type}-state-selector'),
		$result,
		$selector,
		$this
	);
}

// mk-util
//
// Creates utilities based on a map or a list with values.
//
// Utility values are set according to the utility [naming rules](section-concepts.html#kssref-concepts-utility). They can be a string (including empty) or a number. Also, the value can indicate the breakpoint on which it should work - `'tb_lg'`. Even if the breakpoint is passed as a parameter when this mixin is called, then the data about breakpoints from the values map will be more priority. In addition to a specific breakpoint, 2 special values are valid:
// * `bp` - create a value only on breakpoints:	`'r_bp'`, '4gg_bp'
// * `all` - create a normal value and on breakpoints: `'ib_all'`, `'_all'`.
//
// Values for CSS properties can be any CSS values, as well as numbers with `gg` and `su` units. Values with `gg` units are created using the [mk-gtr](#kssref-sass-tools-mixins-mk_gtr) mixin.
//
// ```scss
//$Bgc-map: (
//		'f': #fff,
//		'mn0_lg': #60f,
//		'mn1': #c05,
//);
//
//@include mlu.mk-util('Bgc', $Bgc-map);
// ```
// CSS
// ```css
//.Bgc-f {
//		background-color: #fff;
//}
//
//.Bgc-mn1 {
//		background-color: #c05;
//}
//
//@media (min-width: 960px) {
//		.Bgc-mn0_lg {
//			background-color: #60f;
//		}
//}
// ```
// or with list
// ```scss
//@include mlu.mk-util('Maw', ('100_sm', 32p, 7su));
// ```
// CSS
// ```css
//.Maw32p {
//		max-width: 32%;
//}
//
//.Maw7su {
//		max-width: 28px;
//}
//
//@media (min-width: 520px) {
//		.Maw100_sm {
//			max-width: 100px;
//		}
//}
// ```
// To create position utilities like `T`, `R` etc, pass `-Xy` as utility name and add directions to the values:
// ```scss
//@include mlu.mk-util('-Xy', ('y23', 'r2gg', 'x5x'));
// ```
// CSS
// ```css
//.mY23 {
//		top: 23px;
//		bottom: 23px;
//}
//
//.R2gg {
//		right: 32px;
//		right: calc(var(--mlu-gg) * 2);
//}
//
//.-X5x {
//		right: 5ex;
//		left: 5ex;
//}
// ```
//
// $name - the name of the utility. It can be specified as a CSS class (with a dot) or just a `string`.
// $values - `map` with utility values and CSS properties values. Also you can pass a `list` containing only utility values. It will be converted to CSS values with [convert-util-value](section-sass-tools.html#kssref-sass-tools-functions-utils-convert_util_value).
// $bp = null - breakpoint on which utility values will be generated. Can be any breakpoint from the settings or a special value: `bp` and `all`.
// $states = null - list of state names. For each value of the utility, all states from this list will be generated. Info about states see [here](section-concepts.html#kssref-concepts-utility-states).
// $prop = null - CSS property name.
//
// Styleguide: sass-tools.mixins.utils.mk_util

@mixin mk-util($name, $values, $bp: null, $states: null, $prop: null) {
	$util-name: mlu.check-class($name, 1);
	$prop: if($prop, $prop, mlu.util-prop($util-name));

	@if list.index($-utils-directed, $util-name) {
		$util-name: if($prop, $util-name, null);
		$utils-data: mlu.parse-util-directions($values, $util-name);
		$utils-map: map.get($utils-data, 'utils-map');

		@each $key, $value in $utils-map {
			$util-index: list.index($utils-map, ($key $value));

			@include -generate-util(
				$key,
				$value,
				$bp,
				$states,
				list.nth(map.get($utils-data, 'props'), $util-index),
				list.nth(map.get($utils-data, 'directions'), $util-index)
			);
		}
	} @else {
		@include -generate-util($name, $values, $bp, $states, $prop);
	}
}

// Private mixin that generate utilities CSS.

@mixin -generate-util($name, $values, $bp: null, $states: null, $prop: null, $direct: null) {
	$name: mlu.check-class($name);

	@each $key, $value in $values {
		$util-val-data: mlu.parse-util($key);
		$bp-name: map.get($util-val-data, 'mq');
		$bp-name: if($bp-name, $bp-name, $bp);
		$util-parsed-val: map.get($util-val-data, 'value');

		$selector: $name + $util-parsed-val;
		$css-value: if($value, $value, mlu.convert-util-value($util-parsed-val, $name));

		@if $bp-name == 'all' or $bp-name == 'bp' {
			@include bp-all($selector, if($bp-name == 'all', 1, 0)) {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $css-value);
				}
			}
		} @else if $bp-name {
			@include mgen.bpm($bp-name) {
				#{$selector}_#{$bp-name} {
					@include mk-state(&, $states, if($states, 0, 1)) {
						@include -check-util-direction($direct, $prop, $css-value);
					}
				}
			}
		} @else {
			#{$selector} {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $css-value);
				}
			}
		}
	}
}

// Private mixin that parses combined directions and identifies positioning utilities.

@mixin -check-util-direction($dir, $prop, $value) {
	@if $dir == 'x' {
		$prop: if($prop, $prop + '-', '');
		@include -parse-unit($prop + 'right', $value, 'r');
		@include -parse-unit($prop + 'left', $value, 'l');
	} @else if $dir == 'y' {
		$prop: if($prop, $prop + '-', '');
		@include -parse-unit($prop + 'top', $value, 't');
		@include -parse-unit($prop + 'bottom', $value, 'b');
	} @else if $dir == 'all' {
		$prop: if($prop, $prop + '-', '');
		@each $item in map.values(mlu.$main-directions) {
			@include -parse-unit($prop + $item, $value, string.slice($item, 1, 1));
		}
	} @else {
		@include -parse-unit($prop, $value, $dir);
	}
}

// Private mixin that parses custom units based on directions.

@mixin -parse-unit($prop, $value, $dir) {
	$coef-val: mlu.str2n($value + '_');

	@if meta.type-of($value) == 'number' and math.unit($value) == 'gg' {
		$tmp-val: if($dir == 't' or $dir == 'b', $-gtr-sm-rem, 1);
		$dash-pos: string.index($prop, '-');

		@if $dash-pos and $dir and $dir != 'xy' {
			$prop: string.slice($prop, 1, $dash-pos - 1);
		} @else if $dir != 'xy' {
			$dir: 'xy';
		}

		@include mgs.mk-gtr($tmp-val, $type: $prop, $direct: $dir, $coef: $coef-val);
	} @else if meta.type-of($value) == 'number' and math.unit($value) == 'su' {
		@if $dir == 'xy' {
			@include mgs.mk-gtr-xy($prop, mlu.$su * $coef-val, $-su-rem * $coef-val);
		} @else {
			$tmp-val: if($dir == 't' or $dir == 'b', $-su-rem, mlu.$su);
			#{$prop}: $tmp-val * $coef-val;
		}
	} @else {
		#{$prop}: $value;
	}
}
