@use 'sass:meta';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';

@use 'forward-tools' as ml;

/*
Grid system

Mixins that implement the grid system.

Styleguide: sass-tools.mixins.grid
*/

// mk-gtr
//
// Generate fields or indents in grid-gutters on different breakpoints.
// ```scss
//.block {
//		@include mk-gtr($direct: 'r', $coef: 2);
//}
//
//.foo {
//		@include mk-gtr($direct: 'r', $coef: 2, $css-vars: false);
//}
// ```
// CSS
// ```css
//.block {
//		margin-right: 32px;
//		margin-right: calc(var(--ml-gg) * 2);
//}
//
//.foo {
//		margin-right: 24px;
//}
//
//@media (min-width: 960px) {
//		.foo {
//			margin-right: 32px;
//		}
//}
// ```
//
// $init-gutter = settings.$gtr-sm - initial gutter value out of breakpoint.
// Can be number. If passed '-1', initial gutter will not be generated.
// If you need a gutter in `rem`, pass value in `rem`.
// $type = margin - can be any CSS property, including custom.
// If no `margin`, `padding` or custom property is used, then `$direct` = 'xy' must be specified.
// $direct = 'x' - any of 7 [directions](section-concepts.html#kssref-concepts-utility-dirs).
// $gutters = settings.$grid-gutters - map with gutters values on breakpoints.
// Map item example: `'sm': 12px`. Custom gutters only work when the `$css-vars = false`.
// $calc = settings.$flag-calc-fallback - bool flag for generation CSS `calc()` fallback for old browsers.
// $coef = 1 - coefficient by which the gutter value is multiplied.
// $css-vars = settings.$flag-css-vars - use [CSS custom properties](section-core-styles.html#kssref-core-styles-css_vars) for gutters.
// Works as a [similar flag](section-sass-tools.html#kssref-sass-tools-settings-flags) in the settings.
//
// Styleguide: sass-tools.mixins.grid.mk_gtr

@mixin mk-gtr($init-gutter: ml.$gtr-sm, $type: 'margin',
$gutters: ml.$grid-gutters, $calc: ml.$flag-calc-fallback, $direct: 'x',
$coef: 1, $css-vars: ml.$flag-css-vars) {
	$custom-prop: null;
	$prev-value: ml.$grid-default-gtr;
	$direct-val: null;

	@if string.slice($type, 1, 2) == '--' {
		$direct: 'xy';
		$custom-prop: $type;
	}

	@if meta.type-of($gutters) != 'map' {
		@error 'Wrong type of argument $gutters: `#{meta.type-of($gutters)}`. Expected `map`';
	}

	@if map.has-key(ml.$main-directions, $direct) {
		$direct-val: map.get(ml.$main-directions, $direct);
	}

	@if not $css-vars {
		$prev-value: if(map.has-key($gutters, ml.$bp-xs), map.get($gutters, ml.$bp-xs), $init-gutter);
	}

	@if $init-gutter and $init-gutter != -1 {
		$var-value: if($coef != 1,
		calc(var(#{ml.$var-gg}) * #{$coef}),
		var(#{ml.$var-gg}));

		$var-value-rem: if($coef != 1,
		calc(var(#{ml.$var-gg-rem}) * #{$coef}),
		var(#{ml.$var-gg-rem}));

		$tmp-val: if($calc, calc(#{$prev-value * $coef}), $prev-value * $coef);

		$tmp-val-rem: if($calc,
		calc(#{ml.px2rem($prev-value) * $coef}),
		ml.px2rem($prev-value) * $coef);

		@if math.unit($init-gutter) == 'rem' {
			$prev-value: ml.px2rem($prev-value);
			$tmp-val: $tmp-val-rem;
			$var-value: $var-value-rem;
		}

		@if $direct == 'x' {
			@if not $css-vars or $css-vars == 1 {
				#{$type}-right: if($calc, (ml.$grid-gutter-fallback * $coef), $tmp-val);
				#{$type}-left: if($calc, (ml.$grid-gutter-fallback * $coef), $tmp-val);
				#{$type}-right: $tmp-val;
				#{$type}-left: $tmp-val;
			}

			@if $css-vars {
				#{$type}-right: $var-value;
				#{$type}-left: $var-value;
			}
		} @else if $direct == 'y' {
			@if not $css-vars or $css-vars == 1 {
				#{$type}-top: if($calc, (ml.$gtr-sm * $coef), $tmp-val);
				#{$type}-bottom: if($calc, (ml.$gtr-sm * $coef), $tmp-val);
				#{$type}-top: $tmp-val;
				#{$type}-bottom: $tmp-val;
			}

			@if $css-vars {
				#{$type}-top: $var-value;
				#{$type}-bottom: $var-value;
			}
		} @else if $direct == 'xy' {
			@if not $css-vars or $css-vars == 1 {
				@if $calc {
					#{$type}: (ml.$gtr-sm * $coef) (ml.$grid-gutter-fallback * $coef);
				}

				@include mk-gtr-xy($type, $tmp-val, $tmp-val-rem);
			}

			@if not $custom-prop and $css-vars {
				@include mk-gtr-xy($type, $var-value, $var-value-rem);
			}
		} @else if $direct-val {
			@if not $css-vars or $css-vars == 1 {
				#{$type}-#{$direct-val}: if($calc, (ml.$grid-gutter-fallback * $coef), $tmp-val);
				#{$type}-#{$direct-val}: $tmp-val;
			}

			@if $css-vars {
				#{$type}-#{$direct-val}: $var-value;
			}
		} @else {
			@error 'Invalid gutter direction - `#{$direct}`';
		}
	}

	@if not $css-vars {
		@each $key, $value in $gutters {
			$cur-val: $value;

			@if $prev-value and math.unit($prev-value) == 'rem' {
				$cur-val: ml.px2rem($value);
			} @else if $prev-value and math.is-unitless($prev-value) and $prev-value > -1 {
				$cur-val: ml.str2n($value + '_');
			}

			@if $prev-value != -1 and $cur-val != $prev-value {
				$tmp-val: if($calc, calc(#{$cur-val * $coef}), $cur-val * $coef);
				$tmp-val-rem: if($calc,
				calc(#{ml.px2rem($cur-val) * $coef}),
				ml.px2rem($cur-val) * $coef);

				@include ml.bpm($key) {
					@if $direct == 'x' {
						#{$type}-right: $tmp-val;
						#{$type}-left: $tmp-val;
					} @else if $direct == 'y' {
						#{$type}-top: $tmp-val;
						#{$type}-bottom: $tmp-val;
					} @else if $direct == 'xy' {
						@include mk-gtr-xy($type, $tmp-val, $tmp-val-rem);
					} @else if $direct-val {
						#{$type}-#{$direct-val}: $tmp-val;
					} @else {
						@error 'Invalid gutter direction - `#{$direct}`';
					}
				}
			}

			$prev-value: $cur-val;
		}
	}
}

// Private mixin to create gutters in the 'xy' direction.

@mixin mk-gtr-xy($type, $value, $value-rem) {
	@if ($type == 'padding' or $type == 'margin') and ($value != $value-rem) {
		#{$type}: $value-rem $value;
	} @else {
		#{$type}: $value;
	}
}
