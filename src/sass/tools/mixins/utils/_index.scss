@use 'sass:meta';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';

@forward 'mk-state';
@forward 'mk-util';

@use '../forward-tools' as mlu;
@use '../general' as mgen;
@use '../grid' as mgs;
@use 'mk-util' as mmu;

$-su-rem: mlu.px2rem(mlu.$su);
$-gtr-sm-rem: mlu.px2rem(mlu.$gtr-sm);

$-utils-directed: map.get(mlu.$utils-config, 'directed');

/*
Utilities

Mixins for creating utilities and working with them.

Styleguide: sass-tools.mixins.utils
*/

// bp-all
//
// Generates the CSS rule on breakpoints, adding the name of the breakpoint to the selector, inside the corresponding media query.
//
// ```scss
//@include bp-all('.Bdw1') {
//		border-width: 1px;
//}
// ```
// CSS
// ```css
//.Bdw1 {
//		border-width: 1px;
//}
//
//@media (min-width: 520px) {
//		.Bdw1_sm {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 760px) {
//		.Bdw1_md {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 960px) {
//		.Bdw1_lg {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 1168px) {
//		.Bdw1_xl {
//			border-width: 1px;
//		}
//}
// ```
// You can also use mixin inside the rule. This will work as well as the example above:
// ```scss
//.Bdw1 {
//		@include bp-all() {
//			border-width: 1px;
//		}
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $xs = 1 - any type flag. If equal to 1, then the rule will first be generated outside of breakpoints(in `xs`).
//
// Styleguide: sass-tools.mixins.utils.bp_all

@mixin bp-all($selector: &, $xs: 1) {
	@if not $selector {
		@error '`$selector` argument must not be null.';
	}

	@at-root {
		@if $xs == 1 {
			#{$selector} {
				@content;
			}
		}

		@each $key, $value in mlu.$breakpoints {
			@include mgen.bpm($key) {
				#{$selector}_#{$key} {
					@content;
				}
			}
		}
	}
}

// mk-state
//
// Generates values for utilities in various [states](section-concepts.html#kssref-concepts-utility-states). Names and values of states are set in the [settings](#kssref-sass-tools-settings-utils-states). Usually this mixin is not used separately because it is called inside [mk-util](#kssref-sass-tools-mixins-mk_util).
//
// ```scss
//@include mk-state('.Bgc-mn0', ('h')) {
//		background-color: #60f;
//}
// ```
// CSS
// ```css
//.Bgc-mn0 {
//		background-color: #60f;
//}
//
//.h_Bgc-mn0:hover {
//		background-color: #60f;
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $states = map-keys(settings.$utils-states) -  list of state names to be generated.
// $no-state = 1 - number flag. If equal to 1, then a value without state will be generated as in the example above.
//
// Styleguide: sass-tools.mixins.utils.mk_state

@mixin mk-state($selector: &, $states: map.keys(mlu.$utils-states), $no-state: 1) {
	@if not $selector {
		@error '`$selector` argument must not be null.';
	}

	@at-root {
		@if $no-state == 1 {
			#{$selector} {
				@content;
			}
		}

		$selector: mlu.check-class($selector, 1);

		@each $key, $value in mlu.$utils-states {
			@if list.index($states, $key) {
				$prefix: '.' + $key;

				@if meta.type-of($value) == 'string' {
					#{$prefix}_#{$selector}:#{$value} {
						@content;
					}
				} @else if meta.type-of($value) == 'list' {
					$multi-selector: ();

					@each $item in $value {
						$multi-selector: list.append($multi-selector, $prefix + '_' + $selector + ':' + $item, comma);
					}

					#{$multi-selector} {
						@content;
					}
				} @else {
					#{$prefix}_#{$selector} {
						@content;
					}
				}
			}
		}
	}
}

// mk-util
//
// Creates utilities based on a map or a list with values.
//
// Utility values are set according to the utility [naming rules](section-concepts.html#kssref-concepts-utility). They can be a string (including empty) or a number. Also, the value can indicate the breakpoint on which it should work - `'tb_lg'`. Even if the breakpoint is passed as a parameter when this mixin is called, then the data about breakpoints from the values map will be more priority. In addition to a specific breakpoint, 2 special values are valid:
// * `bp` - create a value only on breakpoints:	`'r_bp'`, '4gg_bp'
// * `all` - create a normal value and on breakpoints: `'ib_all'`, `'_all'`.
//
// Values for CSS properties can be any CSS values, as well as numbers with `gg` and `su` units. Values with `gg` units are created using the [mk-gtr](#kssref-sass-tools-mixins-mk_gtr) mixin.
//
// ```scss
//$Bgc-map: (
//		'f': #fff,
//		'mn0_lg': #60f,
//		'mn1': #c05,
//);
//
//@include mlu.mk-util('Bgc', $Bgc-map);
// ```
// CSS
// ```css
//.Bgc-f {
//		background-color: #fff;
//}
//
//.Bgc-mn1 {
//		background-color: #c05;
//}
//
//@media (min-width: 960px) {
//		.Bgc-mn0_lg {
//			background-color: #60f;
//		}
//}
// ```
// or with list
// ```scss
//@include mlu.mk-util('Maw', ('100_sm', 32p, 7su));
// ```
// CSS
// ```css
//.Maw32p {
//		max-width: 32%;
//}
//
//.Maw7su {
//		max-width: 28px;
//}
//
//@media (min-width: 520px) {
//		.Maw100_sm {
//			max-width: 100px;
//		}
//}
// ```
// To create position utilities like `T`, `R` etc, pass `-Xy` as utility name and add directions to the values:
// ```scss
//@include mlu.mk-util('-Xy', ('y23', 'r2gg', 'x5x'));
// ```
// CSS
// ```css
//.mY23 {
//		top: 23px;
//		bottom: 23px;
//}
//
//.R2gg {
//		right: 32px;
//		right: calc(var(--mlu-gg) * 2);
//}
//
//.-X5x {
//		right: 5ex;
//		left: 5ex;
//}
// ```
//
// $name - the name of the utility. It can be specified as a CSS class (with a dot) or just a `string`.
// $values - `map` with utility values and CSS properties values. Also you can pass a `list` containing only utility values. It will be converted to CSS values with [convert-util-value](section-sass-tools.html#kssref-sass-tools-functions-utils-convert_util_value).
// $bp = null - breakpoint on which utility values will be generated. Can be any breakpoint from the settings or a special value: `bp` and `all`.
// $states = null - list of state names. For each value of the utility, all states from this list will be generated. Info about states see [here](section-concepts.html#kssref-concepts-utility-states).
// $prop = null - CSS property name.
//
// Styleguide: sass-tools.mixins.utils.mk_util

@mixin mk-util($name, $values, $bp: null, $states: null, $prop: null) {
	$util-name: mlu.check-class($name, 1);
	$prop: if($prop, $prop, mlu.util-prop($util-name));

	@if list.index($-utils-directed, $util-name) {
		$util-name: if($prop, $util-name, null);
		$utils-data: mlu.parse-util-directions($values, $util-name);
		$utils-map: map.get($utils-data, 'utils-map');

		@each $key, $value in $utils-map {
			$util-index: list.index($utils-map, ($key $value));

			@include -generate-util(
				$key,
				$value,
				$bp,
				$states,
				list.nth(map.get($utils-data, 'props'), $util-index),
				list.nth(map.get($utils-data, 'directions'), $util-index)
			);
		}
	} @else {
		@include -generate-util($name, $values, $bp, $states, $prop);
	}
}

// Private mixin that generate utilities CSS.

@mixin -generate-util($name, $values, $bp: null, $states: null, $prop: null, $direct: null) {
	$name: mlu.check-class($name);

	@each $key, $value in $values {
		$util-val-data: mlu.parse-util($key);
		$bp-name: map.get($util-val-data, 'mq');
		$bp-name: if($bp-name, $bp-name, $bp);
		$util-parsed-val: map.get($util-val-data, 'value');

		$selector: $name + $util-parsed-val;
		$css-value: if($value, $value, mlu.convert-util-value($util-parsed-val, $name));

		@if $bp-name == 'all' or $bp-name == 'bp' {
			@include bp-all($selector, if($bp-name == 'all', 1, 0)) {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $css-value);
				}
			}
		} @else if $bp-name {
			@include mgen.bpm($bp-name) {
				#{$selector}_#{$bp-name} {
					@include mk-state(&, $states, if($states, 0, 1)) {
						@include -check-util-direction($direct, $prop, $css-value);
					}
				}
			}
		} @else {
			#{$selector} {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $css-value);
				}
			}
		}
	}
}

// Private mixin that parses combined directions and identifies positioning utilities.

@mixin -check-util-direction($dir, $prop, $value) {
	@if $dir == 'x' {
		$prop: if($prop, $prop + '-', '');
		@include -parse-unit($prop + 'right', $value, 'r');
		@include -parse-unit($prop + 'left', $value, 'l');
	} @else if $dir == 'y' {
		$prop: if($prop, $prop + '-', '');
		@include -parse-unit($prop + 'top', $value, 't');
		@include -parse-unit($prop + 'bottom', $value, 'b');
	} @else if $dir == 'all' {
		$prop: if($prop, $prop + '-', '');
		@each $item in map.values(mlu.$main-directions) {
			@include -parse-unit($prop + $item, $value, string.slice($item, 1, 1));
		}
	} @else {
		@include -parse-unit($prop, $value, $dir);
	}
}

// Private mixin that parses custom units based on directions.

@mixin -parse-unit($prop, $value, $dir) {
	$coef-val: mlu.str2n($value + '_');

	@if meta.type-of($value) == 'number' and math.unit($value) == 'gg' {
		$tmp-val: if($dir == 't' or $dir == 'b', $-gtr-sm-rem, 1);
		$dash-pos: string.index($prop, '-');

		@if $dash-pos and $dir and $dir != 'xy' {
			$prop: string.slice($prop, 1, $dash-pos - 1);
		} @else if $dir != 'xy' {
			$dir: 'xy';
		}

		@include mgs.mk-gtr($tmp-val, $type: $prop, $direct: $dir, $coef: $coef-val);
	} @else if meta.type-of($value) == 'number' and math.unit($value) == 'su' {
		@if $dir == 'xy' {
			@include mgs.mk-gtr-xy($prop, mlu.$su * $coef-val, $-su-rem * $coef-val);
		} @else {
			$tmp-val: if($dir == 't' or $dir == 'b', $-su-rem, mlu.$su);
			#{$prop}: $tmp-val * $coef-val;
		}
	} @else {
		#{$prop}: $value;
	}
}

@mixin mk-utils-group($raw-name, $values, $components: ()) {
	$group-data: mlu.new-parse-util($raw-name);
	$group-name: map.get($group-data, 'value');

	@if not map.has-key(mlu.$utils-data, 'groups', 'registry', $group-name) {
		@error 'Group `#{$group-name}` not defined in registry';
	}

	@if list.length($components) > 0 {
		$group-data: $components;
	}

	@each $util in map.get(mlu.$utils-data, 'groups', 'registry', $group-name) {
		@include mmu.new-mk-util(
			$util, $values, if(string.index($util, mlu.$tUCm), (), $group-data)
		);
	}
}

@mixin apply-util($utils, $components: ()) {
	@each $item in $utils {
		$util-data: mlu.new-parse-util($item);
		$abbr-data: mlu.parse-abbr(map.get($util-data, 'value'));
		$util-data: map.merge($util-data, $components);
		$keyword: mlu.$kStOnly;
		$pre-states: map.get($util-data, 'pre-states');
		$post-states: map.get($util-data, 'post-states');

		@if map.get($util-data, 'at-rules') {
			$keyword: mlu.$kArStOnly;
			// It's a bit dangerous to use non-standard fields in map, but it is unlikely that a way to check keywords in the `mk-util` will change
			$util-data: map.set($util-data, 'applyArKw', mlu.$kArOnly);
		}

		@if $pre-states or $post-states {
			@if $pre-states and $post-states {
				$util-data: map.merge(
					$util-data,
					(
						'pre-states': '#{mlu.$states-cmb} ' + $pre-states,
						'post-states':'#{mlu.$states-cmb} ' + $post-states,
					)
				);
			}

			$util-data: map.set($util-data, 'applyStKw', $keyword);
		}

		@include mmu.new-mk-util(
			map.get($abbr-data, 'name'),
			map.get($abbr-data, 'value'),
			map.remove($util-data, 'value'),
			('selector': &)
		);
	}
}
