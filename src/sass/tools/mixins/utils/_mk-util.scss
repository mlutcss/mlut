@use 'sass:meta';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';

@use '../forward-tools' as mlu;
@use '../../functions/general' as mgf;
@use '../general' as mgen;
@use '../grid' as mgs;
@use 'mk-state' as mst;

@mixin new-mk-util($raw-name, $values, $features: (), $options: null) {
	$util-data: mlu.new-parse-util($raw-name);
	$key-name: map.get($util-data, 'value');

	$main-options: -util-main-options($key-name, $options);
	$util-name: map.get($main-options, 'name');
	$prop: map.get($main-options, 'prop');

	@if not map.has-key(mlu.$utils-data, 'utils', 'registry', $key-name) {
		mlu.$utils-data: map.set(
			mlu.$utils-data, 'utils', 'registry', $key-name, if($options, $options, $prop)
		);
	}

	$util-map: ();
	$util-data: map.merge($util-data, $features);
	$is-values-map: meta.type-of($values) == 'map';
	$i: 1;

	@each $key, $value in $values {
		$range-list: if($is-values-map, $key, list.nth($values, $i));

		@if list.is-bracketed($range-list) {
			@include new-mk-util(
				$util-name,
				$options: $options,
				mlu.parse-util-value-range($range-list, $util-name)...
			);
		} @else {
			$util-val-data: mlu.new-parse-util($key);

			@if list.length($util-val-data) < 2 {
				$util-val-data: map.merge($util-data, $util-val-data);
			}

			$util-parsed-val: map.get($util-val-data, 'value');
			$at-rules: map.get($util-val-data, 'at-rules');
			$post-states: map.get($util-val-data, 'post-states');
			$pre-states: map.get($util-val-data, 'pre-states');
			$css-value: $value;

			@if $css-value == null {
				$css-value: mlu.convert-util-value($util-parsed-val, $key-name);
			} @else if $css-value == false {
				$css-value: $util-parsed-val;
			}

			// FOR TESTS ONLY
			@if meta.type-of($css-value) == 'number' and math.unit($css-value) == 'su' {
				$css-value: mlu.su($css-value);
			}

			$separated-value: mlu.util-separated-value($util-parsed-val);
			$selector: mlu.str-escape($util-name + $separated-value);
			$this-util: (
				'name': $util-name,
				'value': $separated-value
			);

			$val-feat-str: mgf.ls-join(
				map.remove($util-val-data, 'value'), ' '
			);

			$st-only: string.index($val-feat-str, mlu.$kStOnly);
			$ar-st-only: string.index($val-feat-str, mlu.$kArStOnly);
			$ar-st: string.index($val-feat-str, mlu.$kArSt);

			@if not string.index($val-feat-str, mlu.$kArOnly) and not $ar-st-only {
				@include mst.new-mk-state(
					$post-states, $pre-states, not $st-only, $selector, $util-name
				) {
					#{$prop}: $css-value;
				}
			}

			@if $at-rules {
				@include mgen.mk-ar($at-rules, $this-util) using ($ar) {
					.#{mlu.str-escape($ar + mlu.$tUCm) + $selector} {
						@if not $ar-st-only {
							#{$prop}: $css-value;
						}

						@if $ar-st or $ar-st-only {
							@include mst.new-mk-state($post-states, $pre-states, false, &, $util-name) {
								#{$prop}: $css-value;
							}
						}
					}
				}
			}
		}

		$i: $i + 1;
	}
}

@function -util-main-options($key-name, $options) {
	$name: null;
	$prop: '';

	@if meta.type-of($options) == 'map' {
		$prop: map.get($options, 'props');

		@if map.has-key($options, 'name') {
			$name: map.get($options, 'name');
		}
	} @else if $options {
		$prop: $options;
	} @else {
		$prop: mlu.util-prop($key-name, 0);
	}

	@if not $prop {
		$prop: $key-name;
	}

	@if not $name {
		$name: if(
			map.has-key(mlu.$utils-data, 'utils', 'registry', $key-name, 'name'),
			map.get(mlu.$utils-data, 'utils', 'registry', $key-name, 'name'),
			$key-name
		);
	}

	@return (
		'name': $name,
		'prop': $prop
	);
}
