@use 'sass:meta';
@use 'sass:list';
@use 'sass:math';

@use 'forward-tools' as mlu;

/*
General

General purpose mixins.

Styleguide: sass-tools.mixins.general
*/

// bpm
//
// Bpm is breakpoint manager.
// ```scss
// @include bpm('md') {
//		.inp--common {
//			padding-left: 48px;
//		}
// }
//
// @include bpm($to: 'lg') {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @include bpm('sm', 'lg') {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
// Compile into:
// ```css
// @media (min-width: 760px) {
//		.inp--common {
//			padding-left: 48px;
//		}
// }
//
// @media (max-width: 959px) {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @media (min-width: 520px) and (max-width: 959px) {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
//
// $from = false - breakpoint. Can be keyword (string) or number. Generate to 'min-width' mediaquery, and `$to` to 'max-width' - 1.
// $to = false - breakpoint. Can be keyword (string) or number. Generate to 'max-width' - 1 mediaquery. Together with `$from` generate to 'min-width and max-width - 1'.
// $opt = false - string with additional media-features to check.
// For example:
// `(orientation: landscape)`,
// `screen and (aspect-ratio: 11/5)`,
// `print`.
// $prop = 'width' - property in mediaquery. Property generate like `#{$type}-#{$prop}`,
// where `$type` can be 'min' or 'max'.
// `$type` depends on availability `$from` and `$to`
// @content - CSS relus that will be placed into mediaquery.
//
// Styleguide: sass-tools.mixins.general.bpm

@mixin bpm($from: false, $to: false, $opt: false, $prop: 'width') {
	$type: 'min';
	$bp-val: ();

	@if $from and $to {
		$type: 'range';
	} @else if $to {
		$type: 'max';
	} @else if not $from {
		@error 'Breakpoint value must be not null.';
	}

	@each $item in ($from, $to) {
		@if meta.type-of($item) == 'string' {
			$bp-val: list.append($bp-val,
			if($item == $to,
			mlu.bp($item) - 1,
			mlu.bp($item)));
		} @else if meta.type-of($item) == 'number' and not math.is-unitless($item) {
			$item-to: $item;

			@if math.unit($item) == 'em' {
				$item-to: mlu.px2em((($item / 1em) * mlu.$browser-font-size) - 1, mlu.$browser-font-size);
			} @else if math.unit($item) == 'rem' {
				$item-to: mlu.px2rem((($item / 1rem) * mlu.$browser-font-size) - 1, mlu.$browser-font-size);
			} @else if math.unit($item) == 'px' {
				$item-to: $item - 1;
			}

			$bp-val: list.append($bp-val,
			if($item == $to, $item-to, $item));
		} @else if meta.type-of($item) != 'bool' or (meta.type-of($item) == 'bool' and $item) {
			@error 'Invalid breakpoint type: `#{meta.type-of($item)}` or value: `#{$item}`';
		}
	}

	$opt: if($opt, $opt + ' ', '');
	$media-str: '';

	@if $type == 'range' {
		$media-str: $opt + '(min-' + $prop + ':' + list.nth($bp-val, 1) + ') and (max-' + $prop + ':' + list.nth($bp-val, 2) + ')';
	} @else {
		$bp-val: list.nth($bp-val, 1);
		$media-str: $opt + '(' + $type + '-' + $prop + ':' + $bp-val + ')';
	}

	@media #{$media-str} {
		@content;
	}
}

// mCl
//
// Generate clearfix for float layout.
// ```scss
//.block {
//		@include mCl;
//}
// ```
// CSS
// ```css
//.block:after {
//		display: table;
//		clear: both;
//		content: '';
//}
// ```
//
// Styleguide: sass-tools.mixins.general.mcl

@mixin mCl {
	&:after {
		display: table;
		clear: both;
		content: '';
	}
}
