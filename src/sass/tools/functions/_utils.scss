@use "sass:list";
@use "sass:map";
@use "sass:meta";
@use "sass:math";
@use "sass:string";

@use "../settings" as mlu;
@use "general" as mgen;
@use "getters" as mget;

/*
Utilities

Functions for working with utilities.

Styleguide: sass-tools.functions.utils
*/

// parse-util
//
// Parse utility value or name. Return map with passed value components:
// - `value` - pure value or name
// - `mq` - breakpoint or any mediaquery
// ```scss
//parse-util("1su_md") => ("value": "1su", "mq": "md")
// ```
//
// $util-val - utility value or name. Type string.
//
// Styleguide: sass-tools.functions.utils.parse_util

@function parse-util($util-val) {
	$divider-pos: if(meta.type-of($util-val) == "string", string.index($util-val, "_"), false);
	$mq: null;

	@if $divider-pos {
		$mq: string.slice($util-val, $divider-pos + 1);
		$util-val: string.slice($util-val, 1, $divider-pos - 1);
	}

	@return (
		"value": if(
			mgen.str2n($util-val) or mget.util-prop($util-val, 0),
			$util-val,
			"-" + $util-val
		),
		"mq": $mq,
	);
}

// parse-util-directions
//
// Parse map or list with directed utility values. Return list with two maps:
// - `(direction: property)`
// - if passed map: `(util-name: (util-value: css-value)`
// - passed list: `(util-name: (util-value, util-value)`
// ```scss
//$M-map: (
//   "b-2gg": -2gg,
//   "b1su": 1su,
//   "y-1gg": -1gg,
//   "xy-auto": auto,
//);
//
//parse-util-directions($M-map, "M") => (
//   ("b": "margin-bottom", "y": "margin", "xy":  "margin"),
//   (
//    "Mb": ("-2gg": -2gg, "1su": 1su),
//    "My": ("-bar_lg": calc(5vw - 1.5rem)),
//    "M": ("auto_all": auto)
//  )
//)
// ```
//
// $map - map with directed utility values.
// $name = null - directed utility name.
//
// Styleguide: sass-tools.functions.utils.parse_util_dir

@function parse-util-directions($map, $name: null) {
	$utils-map: ();
	$prop-direct-map: ();
	$append-item-val: if(
		meta.type-of($map) == "map",
		meta.get-function("merge", false, map),
		meta.get-function("append", false, list)
	);

	@each $key, $value in $map {
		@if meta.type-of($key) != "string" {
			@error "Invalid key format '#{$key}' for '#{$name}' in map of values";
		}

		$dir: string.slice($key, 1, 1);
		$dir-val: map.get(mlu.$main-directions, $dir);
		$util-prop: mget.util-prop($name, 0);
		$util-name: "";

		$utils-map-item-val: -cut-map-item-val($key, $value, 2);

		@if $dir-val {
			@if $name {
				$util-name: $name + $dir;
				$util-prop: $util-prop + "-" + $dir-val;
			} @else {
				$util-name: string.to-upper-case($dir);
				$util-prop: $dir-val;
			}
		} @else if $dir == "x" and string.slice($key, 2, 2) == "y" {
			$utils-map-item-val: -cut-map-item-val($key, $value, 3);

			@if $name {
				$util-name: $name;
				$dir: "xy";
			} @else {
				$util-name: "mXy";
				$dir: "all";
			}
		} @else if $dir == "x" or $dir == "y" {
			@if $name {
				$util-name: $name + $dir;
			} @else {
				$util-name: "m" + string.to-upper-case($dir);
			}
		} @else {
			@error "Invalid direction '#{$dir}' for '#{$name}' in map of values";
		}

		@if not map.has-key($utils-map, $util-name) {
			$utils-map: map.merge($utils-map, ($util-name: $utils-map-item-val));
			$prop-direct-map: map.merge($prop-direct-map, ($dir: $util-prop));
		} @else {
			//This will be refactored when Sass nested map functions will be released
			$utils-map: map.merge(
				$utils-map,
				($util-name: meta.call($append-item-val, map.get($utils-map, $util-name), $utils-map-item-val))
			);
		}
	}

	@return ($prop-direct-map, $utils-map);
}

// Private function that cuts utility value from string with direction

@function -cut-map-item-val($raw-val, $css-val, $val-pos) {
	$util-val: if(
		not mgen.str2n(string.slice($raw-val, $val-pos)),
		string.slice($raw-val, $val-pos + 1),
		string.slice($raw-val, $val-pos)
	);

	@if $css-val {
		@return ($util-val: $css-val);
	}

	@return $util-val;
}

// convert-util-value
//
// Determines the type of utility and, depending on type, calls the converter from the `$util-value-converters` map. If the utility type is not recognized, the [default converter](#kssref-sass-tools-functions-utils-value_converters-def) is called. If the `$utils-value-converters` does not contain a converter for this type, the utility value is returned without conversion. Else the result of the converter work is returned.
// ```scss
//@debug mlu.convert-util-value("2r", "Fz"); // 2rem
//@debug mlu.convert-util-value(100, "Fw"); // 100
// ```
//
// $util-val - utility value
// $name - utility name
//
// Styleguide: sass-tools.functions.utils.convert_util_value

@function convert-util-value($util-val, $name) {
	$util-type: "";

	@each $key, $value in mlu.$util-value-types {
		@if list.index($value, $name) {
			$util-type: $key;
		}
	}

	@return if(
		map.has-key($util-value-converters, $util-type),
		meta.call(
			map.get($util-value-converters, $util-type),
			$util-val
		),
		$util-val
	);
}

// convert-util-value-default
//
// Default converter for utility value to CSS value. Converts global CSS keywords, and numbers with unit aliases.
// ```scss
//@debug mlu.convert-util-value-default(480) // 480px
//@debug mlu.convert-util-value-default("n") // none
// ```
//
// $value - utility value.
//
// Styleguide: sass-tools.functions.utils.value_converters.def

@function convert-util-value-default($value) {
	$val-unit: "";
	$val-number: mgen.str2n($value + "");

	@if meta.type-of($value) == "number" {
		$val-unit: map.get(mlu.$util-units-map, math.unit($value));
	} @else if meta.type-of($value) == "string" and  $val-number {
		$util-unit: string.slice($value, string.length($val-number + "") + 1);
		$val-unit: map.get(mlu.$util-units-map, $util-unit);
	}

	@if $val-unit != "" {
		// Maybe in the future there will be processing of all CSS units, but so far a number with an unknown unit is returned as a string
		@return if(
			$val-unit,
			$val-number * $val-unit,
			string.unquote($value + "")
		);
	}

	@return convert-util-value-keyword($value);
}

// convert-util-value-keyword
//
// Converts aliases to global CSS keywords. If the alias is not found in the `$util-css-keywords`, returns the value without conversion.
// ```scss
//@debug mlu.convert-util-value-keyword("i") // inherit
//@debug mlu.convert-util-value-keyword("b") // "b"
// ```
//
// $value - utility value.
//
// Styleguide: sass-tools.functions.utils.value_converters.kw

@function convert-util-value-keyword($value) {
	@return if(
		map.has-key(mlu.$util-css-keywords, $value),
		map.get(mlu.$util-css-keywords, $value),
		$value
	);
}

// Utilities value converters
//
// All converters are contained in the `$util-value-converters` map. The keys in this map are the utility types and the values are the conversion functions. As in other settings, you can add additional converters in `$util-value-converters-ext`.
//
// Styleguide: sass-tools.functions.utils.value_converters

$util-value-converters: (
	"": meta.get-function("convert-util-value-default"),
	"unitless": meta.get-function("convert-util-value-keyword"),
) !default;

$util-value-converters-ext: (
) !default;

$util-value-converters: map.merge(
	$util-value-converters,
	$util-value-converters-ext
);
