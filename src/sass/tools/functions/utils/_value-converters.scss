@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:math';
@use 'sass:string';

@use 'forward-tools' as mlu;

// convert-util-value
//
// Determines the type of utility and, depending on type, calls the converter from the `$util-value-converters` map. If the utility type is not recognized, the [default converter](#kssref-sass-tools-functions-utils-value_converters-def) is called. If the `$utils-value-converters` does not contain a converter for this type, the utility value is returned without conversion. Else the result of the converter work is returned.
// ```scss
//@debug mlu.convert-util-value('2r', 'Fz'); // 2rem
//@debug mlu.convert-util-value(100, 'Fw'); // 100
// ```
//
// $util-val - utility value
// $name - utility name
// $section = 'utils' - section in the registry in which utility was defined
//
// Styleguide: sass-tools.functions.utils.convert_util_value

// Value converters
//
// Available converters:
// ```scss
//@debug mlu.convert-uv-number(10); // 10px
//@debug mlu.convert-uv-unitless(10); // 10
//@debug mlu.convert-uv-resolution(2x); // 2dppx
//@debug mlu.convert-uv-css-kw('a'); // auto
//@debug mlu.convert-uv-abbr('bgc'); // background-color
// ```
//
// $value - value for converting
// $data = () - map with data required for converting
//
// Styleguide: sass-tools.functions.utils.value_converters

@function convert-util-value($util-val, $name, $section: 'utils') {
	@if meta.type-of($util-val) == 'string' {
		$space: ' ';

		$multi-list-sep: if(
			map.has-key(mlu.$utils-data, $section, 'registry', $name, 'multi-list-separator'),
			map.get(mlu.$utils-data, $section, 'registry', $name, 'multi-list-separator'),
			mlu.$tULs1
		);

		@if string.index($util-val, $multi-list-sep) or string.index($util-val, mlu.$tUSp) {
			$result: ();
			$separator: map.get(mlu.$utils-config, 'tokens-values', $multi-list-sep);

			@each $list in mlu.str-split($util-val, $multi-list-sep) {
				$items: mlu.str-split($list, mlu.$tUSp);
				$length: list.length($items);
				$converted-items: ();

				@each $value in $items {
					$converted-items: list.append(
						$converted-items,
						apply-value-converter($value, $name, $section, $length)
					);
				}

				$result: list.append($result, $converted-items, $separator);
			}

			@return if(
				list.length($result) == 1,
				list.nth($result, 1),
				$result
			);
		}

		@if string.slice($util-val, 1, 1) == mlu.$tURv {
			@return string.unquote(string.slice($util-val, 2));
		}
	}

	$converted: apply-value-converter($util-val, $name, $section);

	@return if(
		meta.type-of($converted) == 'string',
		string.unquote($converted),
		$converted
	);
}

@function apply-value-converter($util-value, $name, $section, $list-length: 1) {
	@if (
		meta.type-of($util-value) == 'string' and
		mlu.str-starts($util-value, mlu.$tURv)
	) {
		@return string.unquote(string.slice($util-value, 2));
	}

	$value-type: if(
		map.has-key(mlu.$utils-data, $section, 'registry', $name, 'value-type'),
		map.get(mlu.$utils-data, $section, 'registry', $name, 'value-type'),
		map.get(mlu.$utils-config, 'default-value-type'),
	);

	$is-pipeline: false;

	@each $item in $value-type {
		@if map.has-key(mlu.$utils-config, 'value-converters', $item) {
			$prev-value: $util-value;

			$util-value: meta.call(
				map.get(mlu.$utils-config, 'value-converters', $item),
				$util-value,
				(
					'name': $name,
					'section': $section,
					'list-length': $list-length,
				)
			);

			@if $util-value != $prev-value and not $is-pipeline {
				@return $util-value;
			}
		} @else if $item == mlu.$tGVcp {
			$is-pipeline: true;
		}
	}

	@return $util-value;
}

@function convert-uv-number($value, $data: ()) {
	$val-number: mlu.str2n($value, true);
	$section: map.get($data, 'section');
	$name: map.get($data, 'name');

	@if meta.type-of($val-number) == 'number' {
		$unit-number: 0;
		$unit: math.unit($val-number);

		$unit-number: map.get(
			mlu.$utils-config, 'units', map.get($data, 'units-key') or 'default', $unit
		);

		@if $unit-number {
			@return mlu.str2n($value + '_') * $unit-number;
		}

		@if $unit == 'su' or $unit == 'gg' {
			$unit-converter: meta.get-function($unit, false, mlu);

			@if map.get(
				mlu.$utils-data, $section, 'registry', $name, 'directions'
			) and map.get($data, 'list-length') == 1 {
				@return (
					meta.call($unit-converter, $val-number, 'rem')
					meta.call($unit-converter, $val-number)
				);
			}

			@return meta.call(
				$unit-converter,
				$val-number,
				map.get(mlu.$utils-data, $section, 'registry', $name, 'default-unit')
			);
		}

		@return $val-number;
	}

	@return $value;
}

@function convert-uv-keyword($value, $data: ()) {
	$name: map.get($data, 'name');
	$section: map.get($data, 'section');

	@if map.has-key(
		mlu.$utils-data, $section, 'registry', $name, 'keywords', $value
	) {
		@return map.get(
			mlu.$utils-data, $section, 'registry', $name, 'keywords', $value
		);
	}

	$link: map.get(
		mlu.$utils-data, $section, 'registry', $name, 'keywords'
	);

	@if map.has-key(mlu.$utils-data, $section, 'keywords', $link, $value) {
		@return map.get(mlu.$utils-data, $section, 'keywords', $link, $value);
	}

	@return if(
		map.has-key(mlu.$utils-data, 'general', 'keywords', $link, $value),
		map.get(mlu.$utils-data, 'general', 'keywords', $link, $value),
		$value
	);
}

@function convert-uv-resolution($value, $data: ()) {
	@return convert-uv-number(
		$value, ('units-key': 'resolution')
	);
}

@function convert-uv-unitless($value, $data: ()) {
	@return mlu.str2n($value) or $value;
}

@function convert-uv-alpha($value, $data: ()) {
	@return convert-uv-number(
		$value, ('units-key': 'alpha')
	);
}

@function convert-uv-css-kw($value, $data: ()) {
	@return if(
		map.has-key(mlu.$utils-data, 'general', 'keywords', 'css', $value),
		map.get(mlu.$utils-data, 'general', 'keywords', 'css', $value),
		$value
	);
}

@function convert-uv-abbr($value, $data: ()) {
	@return (
		mlu.util-prop(mlu.str-ucfirst($value), map.get($data, 'section')) or
		// maybe in the future, the keys of utils in the registry will be unified
		mlu.util-prop($value, map.get($data, 'section')) or
		$value
	);
}

$-tUVar-length: string.length(mlu.$tUVar);

@function convert-uv-var($value, $data: ()) {
	@if (
		meta.type-of($value) != 'string' or
		string.slice($value, 1, $-tUVar-length) != mlu.$tUVar
	) {
		@return $value;
	}

	$var-name: string.slice($value, $-tUVar-length + 1);
	$section: map.get($data, 'section');

	$result: if(
		map.has-key(mlu.$utils-data, $section, 'variables', $var-name),
		map.get(mlu.$utils-data, $section, 'variables', $var-name),
		map.get(mlu.$utils-data, 'general', 'variables', $var-name)
	);

	@if not $result {
		@return mlu.error('Undefined variable: `#{$value}`');
	}

	@return $result;
}

$-tUCp-length: string.length(mlu.$tUCp);

@function convert-uv-cust-prop($value, $data: ()) {
	@if (
		meta.type-of($value) != 'string' or
		string.slice($value, 1, $-tUCp-length) != mlu.$tUCp
	) {
		@return $value;
	}

	$fallback-pos: string.index($value, mlu.$tUFv);

	@if $fallback-pos {
		@return var(
			#{
				'--' + mlu.$util-val-css-var-prefix + string.slice(
					$value, $-tUCp-length + 1, $fallback-pos - 1
				)
			},
			#{
				apply-value-converter(
					string.slice($value, $fallback-pos + 1), $data...
				)
			}
		);
	}

	@return var(#{
		'--' + mlu.$util-val-css-var-prefix + string.slice(
			$value, $-tUCp-length + 1
		)
	});
}

@function convert-uv-color($value, $data: ()) {
	@if map.has-key(
		mlu.$utils-data, 'general', 'keywords', 'colors', $value
	) {
		@return map.get(
			mlu.$utils-data, 'general', 'keywords', 'colors', $value
		);
	}

	@if meta.type-of($value) == 'string' {
		$mod-color-list: mlu.str-split($value, mlu.$tUVm);

		@if list.length($mod-color-list) > 1 {
			$part-color: list.nth($mod-color-list, 1);
			$converted-part: apply-value-converter(
				$part-color, $data...
			);
			$color: mlu.str-hex2color($converted-part);

			@if $color or mlu.is-css-var($converted-part) {
				$part-alpha: list.nth($mod-color-list, 2);
				$alpha: apply-value-converter($part-alpha, 'Op', 'utils');

				@if mlu.is-css-var($alpha) and not string.index($part-alpha, mlu.$tUFv) {
					$alpha: string.insert($alpha, ', 1', -2);
				}

				@return rgba($color or $converted-part, $alpha);
			}
		}
	}

	@return $value;
}
