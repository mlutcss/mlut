@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:math';
@use 'sass:string';

@use '../../settings' as mlu;
@use '../general' as mgen;
@use '../getters' as mget;
@use 'value-converters' as converters;
@forward 'value-converters';

/*
Utilities

Functions for working with utilities.

Styleguide: sass-tools.functions.utils
*/

// parse-util
//
// Parse utility value or name. Return map with passed value components:
// - `value` - pure value or name
// - `mq` - breakpoint or any mediaquery
// ```scss
//parse-util('1su_md') => ('value': '1su', 'mq': 'md')
// ```
//
// $util-val - utility value or name. Type string.
//
// Styleguide: sass-tools.functions.utils.parse_util

$-ar-keywords: list.join(
	map.keys(map.get(mlu.$at-rules-cfg, 'all-breakpoints')),
	map.keys(map.get(mlu.$at-rules-cfg, 'keywords')),
);

$-states-keywords: map.keys(map.get(mlu.$utils-config, 'states', 'keywords'));

$-states-abbrs: list.join(
	map.keys(mlu.$utils-states),
	$-states-keywords
);

@function parse-util($util-val) {
	$divider-pos: if(meta.type-of($util-val) == 'string', string.index($util-val, '_'), false);
	$mq: null;

	@if $divider-pos {
		$mq: string.slice($util-val, $divider-pos + 1);
		$util-val: string.slice($util-val, 1, $divider-pos - 1);
	}

	@return (
		'value': if(
			mgen.str2n($util-val) or mget.util-prop($util-val, 0),
			$util-val,
			'-' + $util-val
		),
		'mq': $mq,
	);
}

@function new-parse-util($raw-value) {
	$raw-value-parts: mgen.str-split($raw-value + '', mlu.$tUCm);
	$result: ();
	$at-rules: null;
	$value: null;
	$states: ();
	$comp-indexes: ();
	$i: 1;

	@if list.length($raw-value-parts) > 1 {
		@each $component in $raw-value-parts {
			$component-trimmed: mgen.str-trim($component);
			$component-item: list.nth(mgen.str-split($component-trimmed, ' '), 1);

			@if string.slice($component-item, 1, 1) == mlu.$tSNot {
				$component-item: string.slice($component-item, 2);
			}

			$part: list.nth(mgen.str-split(
				list.nth(mgen.str-split($component-item, mlu.$tSOr), 1),
				mlu.$tSAnd
			), 1);

			@if not $at-rules and (
				string.index($part, mlu.$tAAr) or list.index($-ar-keywords, $part)
			) {
				$at-rules: $component-trimmed;
				$comp-indexes: map.set($comp-indexes, 'ar', $i);
			} @else if (string.index($component, ' ') or $value) and
				list.index($-states-abbrs, $part) or
				list.index(mlu.$tSCn mlu.$tSRaw mlu.$tSAnd, string.slice($component-item, 1, 1)) {
				$states: list.append($states, $component-trimmed);
				$comp-indexes: map.set(
					$comp-indexes, 'state' + list.length($states), $i
				);
			} @else {
				$value: $component-trimmed;
				$comp-indexes: map.set($comp-indexes, 'value', $i);
			}

			$i: $i + 1;
		}
	} @else {
		$value: $raw-value;
	}

	@if not $value {
		$value: $at-rules;
		$comp-indexes: map.set($comp-indexes, 'value', map.get($comp-indexes, 'ar'));
	} @else if $at-rules {
		$result: map.set($result, 'at-rules', $at-rules);
	}

	@if not $value {
		@return mgen.error('Not specified value or name in string `#{$raw-value}`');
	}

	$i: 1;

	@each $item in $states {
		@if map.get($comp-indexes, 'state' + $i) < map.get($comp-indexes, 'value') {
			$result: map.set($result, 'pre-states', $item);
		} @else {
			$result: map.set($result, 'post-states', $item);
		}

		$i: $i + 1;
	}

	$result: map.set($result, 'value', $value);

	@return $result;
}

// parse-util-directions
//
// Parse a map or list with directed utility values. If utility name is not passed, then the directions in the values will become the names of the utilities: t - T, x - -X etc. Returns a map with parsed data.
// ```scss
//$M-map: (
//   'b-2gg': -2gg,
//   'y--bar_lg': calc(5vw - 1.5rem),
//   'b1su': 1su,
//   'xy-auto_all': auto,
//);
//
//@debug mlu.parse-util-directions($M-map, 'M');
///* (
//  'utils-map': (
//    'Mb': ('-2gg': -2gg, '1su': 1su),
//    'My': ('-bar_lg': calc(5vw - 1.5rem)),
//    'M': ('auto_all': auto)
//  )
//  'props': ('margin-bottom', 'margin', 'margin'),
//  'directions': ('b', 'y', 'xy'),
//) */
// ```
// or with list
// ```scss
//@debug mlu.parse-util-directions(('y23', 'r2r', 'x5gg', 'r32su'), 'P');
///* (
//  'utils-map': (
//    'Py': '23',
//    'Pr': ('2r', '32su'),
//    'Px': '5gg'
//  )
//  'props': ('padding', 'padding-right', 'padding'),
//  'directions': ('y', 'r', 'x'),
//) */
// ```
//
// $values - `map` or `list` with values.
// $name = null - directed utility name.
//
// Styleguide: sass-tools.functions.utils.parse_util_dir

@function parse-util-directions($values, $name: null) {
	$utils-map: ();
	$util-directions: ();
	$directed-props: ();

	$append-item-val: if(
		meta.type-of($values) == 'map',
		meta.get-function('merge', false, map),
		meta.get-function('append', false, list)
	);

	@each $key, $value in $values {
		@if meta.type-of($key) != 'string' {
			@error 'Invalid key format `#{$key}` for `#{$name}` in map of values';
		}

		$dir: string.slice($key, 1, 1);
		$dir-val: map.get(mlu.$main-directions, $dir);
		$util-prop: mget.util-prop($name, 0);
		$util-name: '';

		$utils-map-item-val: -cut-map-item-val($key, $value, 2);

		@if $dir-val {
			@if $name {
				$util-name: $name + $dir;
				$util-prop: $util-prop + '-' + $dir-val;
			} @else {
				$util-name: string.to-upper-case($dir);
				$util-prop: $dir-val;
			}
		} @else if $dir == 'x' and string.slice($key, 2, 2) == 'y' {
			$utils-map-item-val: -cut-map-item-val($key, $value, 3);

			@if $name {
				$util-name: $name;
				$dir: 'xy';
			} @else {
				$util-name: '-Xy';
				$dir: 'all';
			}
		} @else if $dir == 'x' or $dir == 'y' {
			@if $name {
				$util-name: $name + $dir;
			} @else {
				$util-name: '-' + string.to-upper-case($dir);
			}
		} @else {
			@error 'Invalid direction `#{$dir}` for `#{$name}` in map of values';
		}

		@if not map.has-key($utils-map, $util-name) {
			$utils-map: map.merge($utils-map, ($util-name: $utils-map-item-val));
			$util-directions: list.append($util-directions, $dir);
			$directed-props: list.append($directed-props, $util-prop);
		} @else {
			//This will be refactored when Sass nested map functions will be released
			$utils-map: map.merge(
				$utils-map,
				($util-name: meta.call($append-item-val, map.get($utils-map, $util-name), $utils-map-item-val))
			);
		}
	}

	@return (
		'utils-map': $utils-map,
		'props': $directed-props,
		'directions': $util-directions,
	);
}

// Private function that cuts utility value from string with direction

@function -cut-map-item-val($raw-val, $css-val, $val-pos) {
	$util-val: if(
		not mgen.str2n(string.slice($raw-val, $val-pos)),
		string.slice($raw-val, $val-pos + 1),
		string.slice($raw-val, $val-pos)
	);

	@if $css-val {
		@return ($util-val: $css-val);
	}

	@return $util-val;
}

@function convert-util-states($states, $this-util: null, $pre: false) {
	$prefix: '&';
	$suffix: '';

	@if $pre {
		$prefix: '';

		@if string.slice($states, -1) == '.' {
			$states: string.slice($states, 1, -2);
		} @else {
			$suffix: ' ';
		}
	}

	$result: $prefix;
	$or: ', ';

	@each $state in mgen.str-split($states, mlu.$tSOr) {
		@each $item in mgen.str-split($state, mlu.$tSAnd) {
			$converted: '';
			$not: string.slice($item, 1, 1) == mlu.$tSNot;

			@if $not {
				$item: string.slice($item, 2);
			}

			@if map.has-key(mlu.$utils-states, $item) {
				$converted: map.get(mlu.$utils-states, $item);
			} @else if mgen.str-starts($item, mlu.$tSCs) {
				$item-name: string.slice($item, 2);

				@if map.has-key(mlu.$utils-config, 'states', 'custom', $item-name) {
					$converted: map.get(mlu.$utils-config, 'states', 'custom', $item-name);
				} @else {
					@return mgen.error('Undefined custom state: `#{$item}`');
				}
			} @else if mgen.str-starts($item, mlu.$tSCn) {
				$ctx-value: string.slice($item, 2);
				$converted: '.' + mgen.str-escape(
					mlu.$cCtx + util-separated-value($ctx-value)
				);
			} @else if mgen.str-starts($item, mlu.$tSRaw) {
				$converted: string.slice($item, 2);
			} @else if mgen.str-starts($item, mlu.$tSTu) {
				@if not $this-util {
					@return mgen.error('`#{mlu.$tSTu}` cannot be used because $this-util is not passed');
				}

				@if $item == mlu.$tSTucv {
					$converted: mgen.str-escape(mlu.$tSTucv);
				} @else {
					$converted: mgen.check-class($this-util + mgen.str-escape(string.slice($item, 2)));
				}
			} @else if $item == '' {
				$converted: ' ';
			} @else {
				@return mgen.error('Invalid state: `#{$item}`');
			}

			@if $not {
				$converted: ':not(#{$converted})';
			}

			$result: $result + $converted;
		}

		$result:  $result + $suffix + $or + $prefix;
	}

	@return string.slice($result, 1, -(1 + string.length($or) + string.length($prefix)));
}

@function util-separated-value($value) {
	@if $value == '' {
		@return '';
	}

	@return if(
		mgen.str2n($value) or $value == '',
		mlu.$tUNv + $value,
		mlu.$tUSv + $value
	);
}

@function parse-util-value-range($range, $util) {
	$value-data: new-parse-util(list.nth($range, 1));
	$start: map.get($value-data, 'value');
	$start-number: mgen.str2n($start, true);

	@if meta.type-of($start-number) != 'number' {
		@if mgen.str2n($start) {
			@return mgen.error('Unknown unit in $start value in range: `#{$start}`');
		}

		@return mgen.error('Invalid $start value in range: `#{$start}`');
	}

	$result: if(
		list.length($value-data) > 1,
		('features': map.remove($value-data, 'value')),
		()
	);

	$value-unit-name: math.unit($start-number);
	$value-unit: map.get(mlu.$units-all, $value-unit-name);
	$converted-start: converters.convert-util-value($start-number, $util);
	$css-value-unit-name: math.unit($converted-start);
	$css-value-unit: map.get(mlu.$units-all, $css-value-unit-name);

	@if map.has-key(mlu.$general-data, 'units', 'custom', $value-unit-name) and
		map.has-key(mlu.$general-data, '#{$value-unit-name}-values', $css-value-unit-name) {
		$css-value-unit: map.get(
			mlu.$general-data, '#{$value-unit-name}-values', $css-value-unit-name
		);
	}

	$step: if((list.length($range) > 2), list.nth($range, 3), 1);
	$values: ();

	$i: if(
		math.is-unitless($start-number),
		$start-number,
		$converted-start / $css-value-unit
	);

	@while $i <= list.nth($range, 2) {
		$values: map.set($values, $i * $value-unit, $i * $css-value-unit);
		$i: $i + $step;
	}

	$result: map.set($result, 'values', $values);

	@return $result;
}

$util-value-converters: ();

$-fn-name-prefix: 'convert-util-value-';
$-fn-prefix-length: string.length($-fn-name-prefix);

@each $key, $value in meta.module-functions(converters) {
	@if string.index($key, $-fn-name-prefix) {
		$util-value-converters: map.set(
			$util-value-converters, string.slice($key, $-fn-prefix-length + 1), $value
		);
	}
}

mlu.$utils-config: map.set(
	mlu.$utils-config,
	'value-converters',
	map.merge($util-value-converters, map.get(mlu.$utils-config, 'value-converters'))
);
