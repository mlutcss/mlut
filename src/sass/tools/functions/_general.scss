@use 'sass:meta';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';
@use 'sass:list';

@use '../settings' as mlu;

/*
General

General purpose functions.

Styleguide: sass-tools.functions.general
*/

// mlu-str2n
//
// Convert string to number. Returns null if conversion is not possible.
// ```scss
//@debug mlu.str2n('1.5'); // 1.5
//@debug mlu.str2n('1x5'); // 1
//@debug mlu.str2n('xx'); // null
//@debug mlu.str2n('1x5', 1); // 1x5
// ```
//
// $str - string to be converted
// $skip-unknown = false - bool flag. If it on and the string contains an unknown sequence of characters after the number, then the it is returned as is
//
// Styleguide: sass-tools.functions.general.str2n

@function str2n($str, $skip-unknown: false) {
	$value-type: meta.type-of($str);

	@if $value-type == 'number' {
		@return $str;
	}

	@if $value-type != 'string' {
		@return null;
	}

	$negative: string.slice($str, 1, 1) == '-';
	$result: 0;
	$decimal: false;

	@for $i from if($negative, 2, 1) through string.length($str) {
		$char: string.slice($str, $i, $i);
		$digit: string.index(mlu.$dec-digits, $char);

		@if $digit and not $decimal {
			$result: $result * 10 + ($digit - 1);
		} @else if $digit and $decimal {
			$result: $result + math.div($digit - 1, $decimal);
			$decimal: $decimal * 10;
		} @else if $char == '.' and not $decimal {
			$decimal: 10;
		} @else if ($i == 1 and not $negative) or ($i == 2 and $negative) {
			@return null;
		} @else {
			$unit: map.get(mlu.$units-all, string.to-lower-case(string.slice($str, $i)));

			@if not $unit {
				@if $skip-unknown {
					@return $str;
				}

				$unit: 1;
			}

			@return if($negative, -$result, $result) * $unit;
		}
	}

	@return if($negative, -$result, $result);
}

// str-digit-index
//
// Returns the first index of digit in $str, or `null` if digits not found
// ```scss
//@debug mlu.str-digit-index('Mb55'); // 3
//@debug mlu.str-digit-index('Mt-a'); // null
// ```
//
// $str - string for search
//
// Styleguide: sass-tools.functions.general.str_digit_index

@function str-digit-index($str) {
	@if meta.type-of($str) != 'string' {
		@return error('Wrong type of argument $str: `#{meta.type-of($str)}`. Expected `string`');
	}

	@for $i from 1 through string.length($str) {
		@if string.index(mlu.$dec-digits, string.slice($str, $i, $i)) {
			@return $i;
		}
	}

	@return null;
}

// str-ucfirst
//
// Converts the first letter of string to uppercase
// ```scss
//@debug mlu.str-ucfirst('fxg1'); // 'Fxg1'
// ```
//
// $str - string for converting
//
// Styleguide: sass-tools.functions.general.str_ucfirst

@function str-ucfirst($str) {
	@if meta.type-of($str) != 'string' {
		@return error('Wrong type of argument $str: `#{meta.type-of($str)}`. Expected `string`');
	}

	@return string.to-upper-case(string.slice($str, 1, 1)) + string.slice($str, 2);
}

// str-escape
//
// Escape special characters in value for using it in CSS selector.
// ```scss
//@debug mlu.str-escape(':^:&:h'); // '\\:\\^\\:\\&\\:h'
//@debug mlu.str-escape(1.5); // '1\\.5'
// ```
//
// $value - value for escaping
//
// Styleguide: sass-tools.functions.general.str_escape

@function str-escape($value) {
	$str: $value + '';
	$escaped: '';

	@for $i from 1 through string.length($str) {
		$char: string.slice($str, $i, $i);

		@if list.index(mlu.$spec-chars, $char) {
			$char: '\\' + $char;
		}

		$escaped: $escaped + $char;
	}

	@return $escaped;
}

// mlu-check-class
//
// Checks for a dot in the CSS class name depending on the flag.
// ```scss
//mlu-check-class('.block') => '.block'
//mlu-check-class('block') => '.block'
//mlu-check-class('.block', 1) => 'block'
// ```
//
// $name - class name string.
// $only-name = null - bool flag. In you want to get class name without dot pass 1. Else, a value with a dot will be returned.
//
// Styleguide: sass-tools.functions.general.check_class

@function check-class($name, $only-name: null) {
	$name: $name + '';

	@if $only-name {
		@return if(string.slice($name, 1, 1) == '.', string.slice($name, 2), $name);
	}

	@return if(string.slice($name, 1, 1) == '.', $name, '.' + $name);
}

// error
//
// Shows the error text in the test environment or throws an exception in the production.
//
// $message - error message
// $catch = $flag-test-env - bool flag. Catch the error if `true` else throws an exception
//
// Styleguide: sass-tools.functions.general.error

@function error($message, $catch: mlu.$flag-test-env) {
	@if $catch {
		@return 'ERROR: #{$message}';
	}

	@error '#{$message}';
}

@function replace-keyword($list, $keyword, $replacement) {
	@each $item in $list {
		$keyword-pos: string.index($item, $keyword);

		@if $keyword-pos {
			$list: remove-nth($list, list.index($list, $item));

			@each $rep-item in $replacement {
				$item-with-kw: str-replace($item, $keyword, $rep-item);

				@if $item-with-kw != '' {
					$list: list.append($list, $item-with-kw);
				}
			}
		}
	}

	@return $list;
}

@function is-css-var($value, $in-color: false) {
	@return (
		meta.type-of($value) == 'string' and
		(
			str-starts($value, 'var(') or
			(
				$in-color and (
					str-starts($value, 'rgba(var(') or
					str-starts($value, 'rgb(var(') or
					str-starts($value, 'hsla(var(') or
					str-starts($value, 'hsl(var(')
				)
			)
		)
	);
}

// Private functions only for internal usage. I hope that in the future they will be built into Sass. And when it will happens I don't want that their removing broke backward compatibility.

@function ls-implode($list, $separator: '') {
	$result: '';

	@each $item in $list {
		$result: $result + $item + $separator;
	}

	@return string.slice($result, 1, -1 - string.length($separator));
}

@function ls-find($list, $callback, $args...) {
	@if meta.type-of($callback) != 'function' {
		@return error(
			'Wrong type of argument $callback: `#{meta.type-of($callback)}`. Expected `function`'
		);
	}

	$i: 1;

	@each $item in $list {
		@if meta.call($callback, $item, $i, $args...) {
			@return $item;
		}

		$i: $i + 1;
	}

	@return null;
}

@function remove-nth($list, $index) {
	@if meta.type-of($index) != 'number' {
		@return error('Wrong type of argument $index: `#{meta.type-of($index)}`. Expected `number`');
	}

	$result: ();
	$i: 1;

	@each $item in $list {
		@if $i != $index {
			$result: list.append($result, $item);
		}

		$i: $i + 1;
	}

	@return $result;
}

@function str-split($str, $separator: '') {
	$result: ();
	$sep-length: string.length($separator);

	@if $sep-length == 0 {
		@for $i from 1 through string.length($str) {
			$result: list.append($result, string.slice($str, $i, $i));
		}

		@return $result;
	}

	$sep-pos: string.index($str, $separator);

	@while $sep-pos != null {
		$result: list.append($result, string.slice($str, 1, $sep-pos - 1));
		$str: string.slice($str, $sep-pos + $sep-length);

		$sep-pos: string.index($str, $separator);
	}

	@return list.append($result, $str);
}

//Trim so simple because common usage will trim one or zero spaces in one side.

@function str-trim($str) {
	@while 1 {
		@if string.slice($str, 1, 1) == ' ' {
			$str: string.slice($str, 2);
		} @else if string.slice($str, -1) == ' ' {
			$str: string.slice($str, 1, -2);
		} @else {
			@return $str;
		}
	}
}

@function str-replace($str, $old, $new: '') {
	$old-pos: string.index($str, $old);

	@if $old-pos {
		@return string.slice($str, 1, $old-pos - 1) + $new + string.slice($str, $old-pos + string.length($old));
	}

	@return $str;
}

@function str-replace-all($str, $old, $new: '') {
	$old-pos: string.index($str, $old);
	$old-length: string.length($old);
	$result: '';

	@while $old-pos {
		$result: $result + string.slice($str, 1, $old-pos - 1) + $new;
		$str: string.slice($str, $old-pos + $old-length);
		$old-pos: string.index($str, $old);
	}

	@return $result + $str;
}

@function str-starts($str, $substr) {
	@if meta.type-of($str) != 'string' {
		@return error('Wrong type of argument $str: `#{meta.type-of($str)}`. Expected `string`');
	}

	@return string.slice($str, 1, string.length($substr)) == $substr;
}

@function str-hex2color($str) {
	$value-type: meta.type-of($str);

	@if $value-type == 'color' {
		@return $str;
	}

	@if $value-type != 'string' or string.slice($str, 1, 1) != '#' {
		@return null;
	}

	$str-length: string.length($str);

	@if $str-length != 4 and $str-length != 7 {
		@return error('Invalid color format: `#{$str}`. Allowed 3 or 6 hexadecimal digits');
	}

	$r: '';
	$g: '';
	$b: '';
	$str: string.to-lower-case($str);

	$max-length: if(
		$str-length == 4, 1, 2
	);

	@for $i from 2 through $str-length {
		$digit: string.slice($str, $i, $i);

		@if not list.index(mlu.$hex-digits, $digit) {
			@return error('Invalid character: `#{$digit}`. Allowed only hexadecimal digits');
		}

		@if string.length($r) < $max-length {
			$r: $r + $digit;
		} @else if string.length($g) < $max-length {
			$g: $g + $digit;
		} @else {
			$b: $b + $digit;
		}
	}

	@if $str-length == 4 {
		$r: $r + $r;
		$g: $g + $g;
		$b: $b + $b;
	}

	@return rgb(-hex2dec($r), -hex2dec($g), -hex2dec($b));
}

@function -hex2dec($n) {
	$str-number: string.to-lower-case($n);
	$result: 0;
	$base: list.length(mlu.$hex-digits);
	$length: string.length($str-number);

	@for $i from 1 through $length {
		$digit: list.index(mlu.$hex-digits, string.slice($str-number, $i, $i)) - 1;
		$result: $result + $digit * math.pow($base, $length - $i);
	}

	@return $result;
}
