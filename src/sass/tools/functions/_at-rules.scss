/*
At-rules

Functions for working with at-rules.

Styleguide: sass-tools.functions.at_rules
*/

@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
@use 'sass:math';
@use 'sass:meta';

@use 'getters' as mget;
@use 'general' as mgen;
@use 'utils' as mut;
@use '../settings' as mlu;

@function convert-bp-list($bp-list) {
	$from: list.nth($bp-list, 1);
	$from-value: map.get(mlu.$at-rules-cfg, 'all-breakpoints', $from);

	@if not $from-value {
		@return mgen.error(
			'Invalid breakpoint name: `#{$from}`. Allowed only breakpoints and "no breakpoint" keyword',
		);
	}

	$to: if(list.length($bp-list) >= 2, list.nth($bp-list, 2), null);
	$media-str: '(min-width: #{$from-value})';

	@if $to and $from-value == 0 {
		$media-str: '(max-width: #{mget.bp($to) - 1px})';
	} @else if $to {
		$media-str: $media-str + ' and (max-width: #{mget.bp($to) - 1px})';
	}

	@return $media-str;
}

// Converters
//
// Converts abbreviations to at-rules.
//
// Styleguide: sass-tools.functions.at_rules.converters

@function convert-ar-bp($ar, $current-util: null) {
	$result: '';
	$queries: mgen.str-split($ar, ',');

	@each $queary in $queries {
		$result: $result + convert-bp-list(mgen.str-split($queary, ':')) + ', ';
	}

	@return string.slice($result, 1, -3);
}

@function convert-feature-abbr($abbr, $section: 'utils') {
	@if $abbr == '' {
		@return mgen.error('Passed empty string');
	}

	$result: '';
	$feature: mget.util-prop($abbr, 0, $section);

	@if map.has-key(mlu.$utils-data, $section, 'map', $abbr, '') {
		@return "(#{$feature}: #{map.get(mlu.$utils-data, $section, 'map', $abbr, '')})";
	} @else if $feature {
		@return '(#{$feature})';
	}

	$delimiter: null;
	$abbr-feature: null;
	$abbr-value: null;
	$feat-prefix: '';

	@each $item in map.get(mlu.$at-rules-cfg, 'abbr-delimiters') {
		@if not $delimiter and string.index($abbr, $item) {
			$delimiter: $item;
		}
	}

	@if $delimiter {
		$abbr-parts: mgen.str-split($abbr, $delimiter);
		$abbr-feature: list.nth($abbr-parts, 1);
		$abbr-value: list.nth($abbr-parts, 2);

		@if string.index($delimiter, '<') {
			$feat-prefix: 'max-';
		} @else if string.index($delimiter, '>') {
			$feat-prefix: 'min-';
		}

		@if $delimiter == '-' and mgen.str2n($abbr-value) {
			$abbr-value: '-' + $abbr-value;
		}
	} @else {

		$number-index: mgen.str-digit-index($abbr);

		@if $number-index {
			$abbr-feature: string.slice($abbr, 1, $number-index - 1);
			$abbr-value: string.slice($abbr, $number-index);
		} @else {
			@return mgen.error(
				'Invalid feature abbreviation: `#{$abbr}`. `#{$abbr}` is not defined in `#{$section}` section of $utils-data map'
			);
		}
	}

	$feature: mget.util-prop($abbr-feature, 0, $section);
	$feat-value: map.get(mlu.$utils-data, $section, 'map', $abbr-feature, $abbr-value);

	@if not $feat-value {
		$feat-value: mut.convert-util-value($abbr-value, $abbr-feature, $section);
	}

	@if meta.type-of($feat-value) == 'number' {
		$value-unit: math.unit($feat-value);

		@if $value-unit == 'su' {
			$feat-value: ($feat-value / 1su * mlu.$su);
		}

		@if $delimiter == '<' or $delimiter == '>' {
			$value-diff: $feat-value / mgen.str2n($feat-value + '');

			@if $value-unit == 'rem' or $value-unit == 'em' {
				$value-diff: $value-diff * 0.06; // 1px = 0.062rem
			} @else if $value-unit != 'px' and $value-unit != '' {
				// calculations for other units can be added in the future
				$value-diff: $value-diff * 0.01;
			}

			@if $delimiter == '<' {
				$value-diff: $value-diff * -1;
			}

			$feat-value: $feat-value + $value-diff;
		}
	}

	@return '(#{$feat-prefix + $feature}: #{$feat-value})';
}

// convert-ar-media
//
// Converts abbreviations and breakpoints to media query list.
// ```scss
//@debug mlu.convert-ar-media('scr:fc'); // 'screen and (forced-colors)'
//@debug mlu.convert-ar-media('c<256,-xs:-sm'); // '(max-color: 255),(max-width: 519px)'
// ```
//
// $ar - string with abbreviations
//
// Styleguide: sass-tools.functions.at_rules.converters.media

@function convert-ar-media($ar, $current-util: null) {
	$result: '';
	$queries: mgen.str-split($ar, ',');
	$and: ' and ';
	$or: ', ';

	@each $queary in $queries {
		$queary-list: mgen.str-split($queary, ':');
		$bp-range: false;

		@each $item in $queary-list {
			@if map.has-key(mlu.$at-rules-data, 'media', 'types', $item) {
				$result: $result + map.get(mlu.$at-rules-data, 'media', 'types', $item);
			} @else if string.slice($item, 1, 1) == '-' {
				$item-name: string.slice($item, 2);

				@if map.has-key(mlu.$at-rules-cfg, 'all-breakpoints', $item-name) and not $bp-range {
					$bp-list: ($item-name);
					$next-item-name: null;
					$item-index: list.index($queary-list, $item);

					@if $item-index < list.length($queary-list) {
						$next-item: list.nth($queary-list, $item-index + 1);
						$next-item-name: if(
							string.slice($next-item, 1, 1) == '-',
							string.slice($next-item, 2),
							null,
						);
					}

					@if map.has-key(mlu.$at-rules-cfg, 'all-breakpoints', $next-item-name) {
						$bp-list: list.append($bp-list, $next-item-name);
						$bp-range: true;
					}

					$result: $result + convert-bp-list($bp-list);
				} @else if map.has-key(mlu.$at-rules-data, 'media', 'custom', $item-name) {
					$result: $result + map.get(mlu.$at-rules-data, 'media', 'custom', $item-name);
				} @else if $bp-range {
					$result: string.slice($result, 1, -(1 + string.length($and)));
				} @else {
					@return mgen.error('Undefined custom media query: `#{$item}`');
				}
			} @else {
				$result: $result + convert-feature-abbr($item, 'media');
			}

			$result: $result + $and;
		}

		$result: string.slice($result, 1, -(1 + string.length($and))) + $or;
	}

	@return string.slice($result, 1, -(1 + string.length($or)));
}

@function convert-ar-supports($ar, $current-util: null) {
	@if $ar == '' and $current-util {
		@return convert-feature-abbr($current-util);
	}

	$result: '';
	$delimiter: ':';
	$operator: ' and ';

	@if string.index($ar, ',') {
		@if string.index($ar, ':') {
			@return mgen.error('Different delimiters are not allowed in one abbreviations list');
		}

		$delimiter: ',';
		$operator: ' or ';
	}

	@each $item in mgen.str-split($ar, $delimiter) {
		$converted: '';
		$not: string.slice($item, 1, 1) == '!';
		$expr: if($not, string.slice($item, 2), $item);

		@if string.slice($expr, 1, 1) == '-' {
			$expr-name: string.slice($expr, 2);

			@if map.has-key(mlu.$at-rules-data, 'supports', 'custom', $expr-name) {
				$converted: map.get(mlu.$at-rules-data, 'supports', 'custom', $expr-name);
			} @else {
				@return mgen.error('Undefined custom supports condition: `#{$expr}`');
			}
		} @else if $expr == '&' {
			@if not $current-util {
				@return mgen.error('`&` cannot be used because $current-util is not passed');
			}

			$converted: convert-feature-abbr($current-util);
		} @else {
			$converted: convert-feature-abbr(mgen.str-ucfirst($expr));
		}

		@if $not {
			$converted: '(not #{$converted})';
		}

		$result: $result + $converted + $operator;
	}

	@return string.slice($result, 1, -(1 + string.length($operator)));
}

@each $key, $value in mlu.$at-rules-data {
	@if meta.function-exists('convert-ar-#{$key}') {
		mlu.$at-rules-data: map.set(
			mlu.$at-rules-data, $key, 'converter', meta.get-function('convert-ar-#{$key}')
		);
	}
}
