/*
At-rules

Functions for working with at-rules.

Styleguide: sass-tools.functions.at_rules
*/

@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
@use 'sass:math';
@use 'sass:meta';

@use 'getters' as mget;
@use 'general' as mgen;
@use 'utils' as mut;
@use '../settings' as mlu;

@function convert-bp-list($bp-list) {
	$from: list.nth($bp-list, 1);
	$from-value: map.get(mlu.$at-rules-data, 'all-breakpoints', $from);

	@if not $from-value {
		@return mgen.error(
			'Invalid breakpoint name: `#{$from}`. Allowed only breakpoints and "no breakpoint" keyword',
		);
	}

	$to: if(list.length($bp-list) >= 2, list.nth($bp-list, 2), null);
	$media-str: '(min-width: #{$from-value})';

	@if $to and $from-value == 0 {
		$media-str: '(max-width: #{mget.bp($to) - 1px})';
	} @else if $to {
		$media-str: $media-str + ' and (max-width: #{mget.bp($to) - 1px})';
	}

	@return $media-str;
}

@function convert-ar-bp($ar) {
	$result: '';
	$queries: mgen.str-split($ar, ',');

	@each $queary in $queries {
		$result: $result + convert-bp-list(mgen.str-split($queary, ':')) + ',';
	}

	@return string.slice($result, 1, -2);
}

@function convert-feature-abbr($abbr, $section: 'utils') {
	$result: '';
	$feature: mget.util-prop($abbr, 0, $section);

	@if map.has-key(mlu.$utils-data, $section, 'map', $abbr, '') {
		@return "(#{$feature}: #{map.get(mlu.$utils-data, $section, 'map', $abbr, '')})";
	} @else if $feature {
		@return '(#{$feature})';
	}

	$delimiter: null;
	$abbr-feature: null;
	$abbr-value: null;
	$feat-prefix: '';

	@each $item in map.get(mlu.$at-rules-data, 'abbr-delimiters') {
		@if not $delimiter and string.index($abbr, $item) {
			$delimiter: $item;
		}
	}

	@if $delimiter {
		$abbr-parts: mgen.str-split($abbr, $delimiter);
		$abbr-feature: list.nth($abbr-parts, 1);
		$abbr-value: list.nth($abbr-parts, 2);

		@if string.index($delimiter, '<') {
			$feat-prefix: 'max-';
		} @else if string.index($delimiter, '>') {
			$feat-prefix: 'min-';
		}

		@if $delimiter == '-' and mgen.str2n($abbr-value) {
			$abbr-value: '-' + $abbr-value;
		}
	} @else {

		$number-index: mgen.str-digit-index($abbr);

		@if $number-index {
			$abbr-feature: string.slice($abbr, 1, $number-index - 1);
			$abbr-value: string.slice($abbr, $number-index);
		} @else {
			@return mgen.error(
				'Invalid feature abbreviation: `#{$abbr}`. `#{$abbr}` is not defined in `#{$section}` section of $utils-data map'
			);
		}
	}

	$feature: mget.util-prop($abbr-feature, 0, $section);
	$feat-value: map.get(mlu.$utils-data, $section, 'map', $abbr-feature, $abbr-value);

	@if not $feat-value {
		$feat-value: mut.convert-util-value($abbr-value, $abbr-feature, $section);
	}

	@if meta.type-of($feat-value) == 'number' {
		$value-unit: math.unit($feat-value);

		@if $value-unit == 'su' {
			$feat-value: ($feat-value / 1su * mlu.$su);
		}

		@if $delimiter == '<' or $delimiter == '>' {
			$value-diff: $feat-value / mgen.str2n($feat-value + '');

			@if $value-unit == 'rem' or $value-unit == 'em' {
				$value-diff: $value-diff * 0.06; // 1px = 0.062rem
			} @else if $value-unit != 'px' and $value-unit != '' {
				// calculations for other units can be added in the future
				$value-diff: $value-diff * 0.01;
			}

			@if $delimiter == '<' {
				$value-diff: $value-diff * -1;
			}

			$feat-value: $feat-value + $value-diff;
		}
	}

	@return '(#{$feat-prefix + $feature}: #{$feat-value})';
}
