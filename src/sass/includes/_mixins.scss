/*
Mixins

Useful mixins. All MLUT mixins have 'mlu' prefix. You can find all mixins in `sass/includes/_mixins.scss`.

Styleguide: sass-tools.mixins
*/

// mlu-bpm
//
// Bpm is breakpoint manager.
// ```scss
// @include mlu-bpm("md") {
//		.input--common {
//			padding-left: 48px;
//		}
// }
//
// @include mlu-bpm($to: "lg") {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @include mlu-bpm("sm", "lg") {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
// Compile into:
// ```css
// @media (min-width: 760px) {
//		.input--common {
//			padding-left: 48px;
//		}
// }
//
// @media (max-width: 959px) {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @media (min-width: 520px) and (max-width: 959px) {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
//
// $from = false - breakpoint. Can be keyword (string) or number. Generate to 'min-width' mediaquery, and `$to` to 'max-width' - 1.
// $to = false - breakpoint. Can be keyword (string) or number. Generate to 'max-width' - 1 mediaquery. Together with `$from` generate to 'min-width and max-width - 1'.
// $opt = false - string with additional media-features to check.
// For example:
// `(orientation: landscape)`,
// `screen and (aspect-ratio: 11/5)`,
// `print`.
// $prop = "width" - property in mediaquery. Property generate like `#{$type}-#{$prop}`,
// where `$type` can be 'min' or 'max'.
// `$type` depends on availability `$from` and `$to`
// @content - CSS relus that will be placed into mediaquery.
//
// Styleguide: sass-tools.mixins.bpm

@mixin mlu-bpm($from: false, $to: false, $opt: false, $prop: "width") {
	$type: "min";
	$bp-val: ();

	@if $from and $to {
		$type: "range";
	} @else if $to {
		$type: "max";
	} @else if not $from {
		@error "Breakpoint value must be not null.";
	}

	@each $item in ($from, $to) {
		@if type-of($item) == "string" {
			$bp-val: append($bp-val,
			if($item == $to,
			mlu-breakpoint($item) - 1,
			mlu-breakpoint($item)));
		} @else if type-of($item) == "number" and not unitless($item) {
			$item-to: $item;

			@if unit($item) == "em" {
				$item-to: mlu-px2em((($item / 1em) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "rem" {
				$item-to: mlu-px2rem((($item / 1rem) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "px" {
				$item-to: $item - 1;
			}

			$bp-val: append($bp-val,
			if($item == $to, $item-to, $item));
		} @else if type-of($item) != "bool" or (type-of($item) == "bool" and $item) {
			@error "Invalid breakpoint type: '#{type-of($item)}' or value: '#{$item}'";
		}
	}

	$opt: if($opt, $opt + " ", "");
	$media-str: "";

	@if $type == "range" {
		$media-str: $opt + "(min-" + $prop + ":" + nth($bp-val, 1) + ") and (max-" + $prop + ":" + nth($bp-val, 2) + ")";
	} @else {
		$bp-val: nth($bp-val, 1);
		$media-str: $opt + "(" + $type + "-" + $prop + ":" + $bp-val + ")";
	}

	@media #{$media-str} {
		@content;
	}
}

// mlu-mods-from-sprite
//
// Generator BEM modifiers for block with icon.
// ```scss
//$icons: (
//		"vk": (27px, 16px, -5px, -5px),
//		"fb": (13px, 28px, -27px, -5px),
//);
//
//.soc-icon {
//		@include mlu-mods-from-sprite($icons);
//}
// ```
// CSS
// ```css
//.soc-icon--vk:before {
//		width: 27px;
//		height: 16px;
//		background-position-x: -5px;
//}
//
//.soc-icon--fb:before {
//		width: 13px;
//		height: 28px;
//		background-position-x: -27px;
//}
// ```
//
// $sprite - map with icons data. Icon rendered as a pseudo-element.
// Sprite item example: `modifier-name: (width, height, bgpx, bgpy)`. <br>
// If icons have the same sizes you can write in map only 2 params: `modifier-name: (bgpx, bgpy)`. <br>
// All icon data lists must be equal length. <br>
// If one or some parameters the same in all icons, it will not be
// generated in modifiers that DRY. Write repeating
// parameter in block class.
// $pseudo = "before" - pseudo-element in which the icon will be inserted.
//
// Styleguide: sass-tools.mixins.mods_from_sprite

@mixin mlu-mods-from-sprite($sprite, $pseudo: "before") {
	@if type-of($sprite) != "map" {
		@error "Wrong type of argument $sprite: '#{type-of($sprite)}'. Expected 'map'";
	}

	$diff-prop-flags: (false, false, false, false);
	$icons-data-list: map-values($sprite);

	@each $value in $icons-data-list {
		$i: index($icons-data-list, $value);

		@if $i > 1 {
			$prev-value: nth($icons-data-list, $i - 1);

			@if length($value) != length($prev-value) {
				@error "Invalid format of sprite item data: all icons data lists must have equal count of parameters";
			}

			@for $j from 1 through length($value) {
				@if nth($value, $j) != nth($prev-value, $j) {
					$diff-prop-flags: set-nth($diff-prop-flags, $j, 1);
				}
			}
		}
	}

	@each $key, $value in $sprite {
		$val-length: length($value);

		@at-root {
			&--#{$key}:#{$pseudo} {
				@if $val-length == 4 {
					@if nth($diff-prop-flags, 1) {
						width: nth($value, 1);
					}

					@if nth($diff-prop-flags, 2) {
						height: nth($value, 2);
					}
				} @else if $val-length != 2 {
					@error "Invalid format of sprite item data: '(#{$value})'. Expected 2 or 4 parameters";
				}

				@if nth($diff-prop-flags, $val-length - 1) and nth($diff-prop-flags, $val-length) {
					background-position: nth($value, $val-length - 1) nth($value, $val-length);
				} @else if nth($diff-prop-flags, $val-length - 1) {
					background-position-x: nth($value, $val-length - 1);
				} @else if nth($diff-prop-flags, $val-length) {
					background-position-y: nth($value, $val-length);
				}
			}
		}
	}
}

// mlu-def-hover
//
// Simple hover wich change color
// to lighter on hover and darker on active.
// ```scss
//.btn--common {
//		@include mlu-def-hover(#f00);
//}
// ```
// CSS
// ```css
//.btn--common:hover,
//.btn--common:focus {
//		background-color: #ff2929;
//}
//
//.btn--common:active {
//		background-color: #e60000;
//}
// ```
//
// $color - init color that will change.
// $prop = background-color - CSS property that will change.
// $lighten = 8% - percent on which the `$color` will become lighten
// with sass function `lighten` on `:hover`.
// $darken = $lighten \- 3 - the same at `$lighten` but `$color` will change
// on `:active`.
//
// Styleguide: sass-tools.mixins.def_hover

@mixin mlu-def-hover($color, $prop: "bgc", $lighten: 8%, $darken: ($lighten - 3)) {
	$prop: if($prop == "bgc", "background-color", $prop);

	&:hover,
	&:focus {
		#{$prop}: lighten($color, $lighten);
	}

	&:active {
		#{$prop}: darken($color, $darken);
	}
}

// mlu-clearfix
//
// Generate clearfix for float layout.
// ```scss
//.block {
//		@include mlu-clearfix;
//}
// ```
// CSS
// ```css
//.block:after {
//		display: table;
//		clear: both;
//		content: "";
//}
// ```
//
// Styleguide: sass-tools.mixins.clearfix
@mixin mlu-clearfix {
	&:after {
		display: table;
		clear: both;
		content: "";
	}
}

// mlu-generate-gutter
//
// Generate fields or indents in grid-gutters on different breakpoints.
// ```scss
//.block {
//		@include mlu-generate-gutter($direct: "right", $coef: 2);
//}
// ```
// CSS
// ```css
//.block {
//		margin-right: 24px;
//}
//
//@media (min-width: 960px) {
//		.block {
//			margin-right: 32px;
//		}
//}
// ```
//
// $init-gutter = $mlu-gtr-sm - initial gutter value out of breakpoint.
// Can be number. If passed '-1', initial gutter will not be generated.
// $type = margin - can be `margin` or `padding`.
// $direct = "x" - can take 4 main directions from [$mlu-main-directions](#kssref-sass-tools-settings-general)
// or combined direction: 'x'(left right), 'y'(top bottom)
// and 'xy'(left right top bottom).
// $gutters = $mlu-grid-gutters - map with gutters values on breakpoints.
// Map item example: `"sm": 12px`.
// $calc = false - bool flag for generation CSS `calc()` fallback for old browsers.
// $coef = 1 - coefficient by which the gutter value is multiplied
//
// Styleguide: sass-tools.mixins.generate_gutter

@mixin mlu-generate-gutter($init-gutter: $mlu-gtr-sm, $type: "margin",
$gutters: $mlu-grid-gutters, $calc: false, $direct: "x", $coef: 1) {
	@if not ($type == "margin" or $type == "padding") {
		@error "Invalid gutter type - '#{$type}'! Allowable margin or padding";
	}

	@if type-of($gutters) != "map" {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'map'";
	}

	$prev-value: if(map-has-key($gutters, $mlu-bp-xs), map-get($gutters, $mlu-bp-xs), $init-gutter);

	@if $init-gutter and $init-gutter != -1 {
		$tmp-val: if($calc, calc(#{$prev-value * $coef}), $prev-value * $coef);

		@if $direct == "x" {
			#{$type}-right: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
			#{$type}-left: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
			#{$type}-right: $tmp-val;
			#{$type}-left: $tmp-val;
		} @else if $direct == "y" {
			#{$type}-top: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
			#{$type}-bottom: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
			#{$type}-top: $tmp-val;
			#{$type}-bottom: $tmp-val;
		} @else if $direct == "xy" {
			#{$type}: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
			#{$type}: $tmp-val;
		} @else if index($mlu-main-directions, $direct) {
			#{$type}-#{$direct}: $tmp-val;
		} @else {
			@error "Invalid gutter direction - '#{$direct}'";
		}
	}

	@each $key, $value in $gutters {
		$cur-val: if($prev-value and unit($prev-value) == "rem", mlu-px2rem($value), $value);

		@if $prev-value != -1 and $cur-val != $prev-value {
			@include mlu-bpm($key) {
				$tmp-val: if($calc, calc(#{$cur-val * $coef}), $cur-val * $coef);

				@if $direct == "x" {
					#{$type}-right: $tmp-val;
					#{$type}-left: $tmp-val;
				} @else if $direct == "y" {
					#{$type}-top: $tmp-val;
					#{$type}-bottom: $tmp-val;
				} @else if $direct == "xy" {
					#{$type}: $tmp-val;
				} @else if index($mlu-main-directions, $direct) {
					#{$type}-#{$direct}: $tmp-val;
				} @else {
					@error "Invalid gutter direction - '#{$direct}'";
				}
			}
		}

		$prev-value: $cur-val;
	}
}

// mlu-icon
//
// Generate block with icon from css-sprite in pseudo-element.
// ```scss
//.icon {
//		@include mlu-icon();
//}
// ```
// CSS
// ```css
//.icon {
//		position: relative;
//}
//
//.icon:before {
//		position: absolute;
//		background-image: url("../img/css_sprites.png");
//		background-repeat: no-repeat;
//		content: "";
//}
//```
//
// $sprite =  "../img/css_sprites.png" - path to css-sprite in png. Can be string.
// $pseudo = "before" - type of pseudo-element: before or after.
// @content - can take additional CSS into pseudo-element.
//
// Styleguide: sass-tools.mixins.icon

@mixin mlu-icon($sprite: "../img/css_sprites.png", $pseudo: "before") {
	position: relative;

	&:#{$pseudo} {
		position: absolute;
		background-image: url($sprite);
		background-repeat: no-repeat;
		content: "";

		@content;
	}
}

// mlu-circle
//
// Generate circle.
// ```scss
//.block {
//		@include mlu-circle(32px, #f00);
//}
// ```
// CSS
// ```css
//.block {
//		width: 32px;
//		height: 32px;
//		background-color: #f00;
//		border-radius: 50%;
//}
// ```
//
// $diametr - circle diametr. Can be number.
// $bgc = transparent - circle `background-color`. Can be color.
//
// Styleguide: sass-tools.mixins.circle

@mixin mlu-circle($diametr, $bgc: transparent) {
	width: $diametr;
	height: $diametr;
	background-color: $bgc;
	border-radius: 50%;
}

// mlu-triangle
//
// Generate blank for border triangle.
// ```scss
//.block {
//		@include mlu-triangle(14px);
//}
// ```
// CSS
// ```css
//.block {
//		width: 0px;
//		height: 0px;
//		border: 14px transparent solid;
//}
// ```
//
// $size - triangle size.
// For create triangle you need to add `border-color` for one of side
// after this mixin.
// For example: `border-top-color: #f00`.
//
// Styleguide: sass-tools.mixins.triangle

@mixin mlu-triangle($size) {
	width: 0px;
	height: 0px;
	border: $size transparent solid;
}

// mlu-bgi-hexagon
//
// Generate hexagon with CSS `linear-gradient()` in `background-image`. See demo [here](section-examples.html#kssref-examples-other).
// ```scss
//.block {
//		@include mlu-bgi-hexagon($bgc: (#306, #d15));
//}
// ```
// CSS
// ```css
//.block {
//		box-sizing: border-box;
//		background-repeat: no-repeat;
//		background-position: 0px 0px, 100% 0px, 50% 50%, 0px 102%, 100% 102%;
//		background-size: 51% 27%, 51% 27%, 100% 48%, 51% 28%, 51% 28%;
//		background-image: linear-gradient(150deg, transparent 50%, #306 50%), linear-gradient(-150deg, transparent 50%, #306 50%), linear-gradient(#306, #d15), linear-gradient(-330deg, transparent 50%, #d15 50%), linear-gradient(330deg, transparent 50%, #d15 50%);
//}
// ```
//
// $edge-ang = 150deg - linear-gradient angle of hexagon edges. Can be only number in `deg`.
// $edge-cs = 50% - is color-stop in linear-gradient of hexagon edges. Can be number with unit.
// $bgc = #000 - hexagon color. It can be single color or list in linear-gradient
// value format. For example: `(167deg, blue 50%, #f0f, #000)`. <br>
// Angle in gradient can be only number in `deg`. If you pass gradient value,
// top hexagon edge get first color, bottom edge get last color and
// hexagon body get full gradient.
// $body-size = (100% 48%) - `background-size` of linear-gradient of hexagon body.
// $change = false - bool flag for generate a change in color or size of an existing hexagon.
//
// Styleguide: sass-tools.mixins.bgi_hexagon

// Hexagon
//
// Hexagon demo generated with [mlu-bgi-hexagon](section-sass-tools.html#kssref-sass-tools-mixins-bgi_hexagon) mixin.
//
// Markup:
// <div class="test-hex"></div>
//
// Styleguide: examples.other.hexagon

@mixin mlu-bgi-hexagon($edge-ang: 150deg, $edge-cs: 50%, $bgc: #000,
$body-size: (100% 48%), $change: false) {

	@if not (type-of($edge-ang) == "number" and unit($edge-ang) == "deg") {
		@error "Invalid value of argument $edge-and - '#{$edge-ang}'. Expected angle in deg.";
	}

	$first-color: $bgc;
	$last-color: $first-color;
	$body-gradient: ($bgc, $bgc);
	$edge-ang-bot: $edge-ang + 180;

	@if type-of($bgc) == "list" {
		$first-color: nth(nth($bgc, 1), 1);
		$val-type: type-of($first-color);

		@if $val-type == "number" and unit($first-color) == "deg" {
			$first-color: nth(nth($bgc, 2), 1);
		} @else if $val-type != "color" or ($val-type == "number" and unitless(nth($bgc, 1))) {
			@error "Invalid gradient format: first value can be angle in deg or color but now value is '#{$first-color}'";
		}

		$last-color: nth(nth($bgc, length($bgc)), 1);
		$body-gradient: $bgc;
	} @else if type-of($bgc) != "color" {
		@error "Wrong type of argument $bgc: '#{type-of($bgc)}'. Expected 'color' or 'list'";
	}

	@if not $change {
		box-sizing: border-box;
		background-repeat: no-repeat;
		background-position: 0px 0px, 100% 0px, 50% 50%, 0px 102%, 100% 102%;
	}

	@if not $change or $body-size != (100% 48%) {
		background-size: 51% 27%, 51% 27%, $body-size, 51% 28%, 51% 28%;
	}

	background-image: linear-gradient($edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient(-$edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient($body-gradient),
		linear-gradient(-$edge-ang-bot, transparent $edge-cs, $last-color $edge-cs),
		linear-gradient($edge-ang-bot, transparent $edge-cs, $last-color $edge-cs);
}

// mlu-restore-outline
//
// Restore default browser outline on focus state.
// ```scss
//.link {
//		@include mlu-restore-outline;
//}
// ```
// CSS
// ```css
//.link:focus {
//		outline: 1px dotted #212121;
//		outline: -webkit-focus-ring-color auto 5px;
//}
// ```
//
// Styleguide: sass-tools.mixins.restore_outline

@mixin mlu-restore-outline {
	&:focus {
		outline: 1px dotted #212121;
		outline: -webkit-focus-ring-color auto 5px;
	}
}

// mlu-W
//
// Set `width` on different breakpoints.
// It works similarly like [W utility](section-core-utils.html#kssref-core-utils-bxz-w).
// ```scss
//.block {
//		@include mlu-W(2, "sm");
//		@include mlu-W(4gs, "lg");
//}
// ```
// CSS
// ```css
//@media (min-width: 520px) {
//		.block {
//			width: calc(16.666% - 24px);
//		}
//}
//
//@media (min-width: 960px) {
//		.block {
//			width: calc(16.666% - 32px);
//		}
//
//		.block {
//			width: 33.333%;
//		}
//}
// ```
//
// $width - can be in grid-columns(unitless number, or `gc` unit), grid-spans(`gs`),
// any CSS units(`px`, `rem` etc) or `auto`. <br> Grid units calculated to %
// according to the formula '`n / $cols * 100%`' and rounded by
// [mlu-decimal-floor](section-sass-tools.html#kssref-sass-tools-functions-decimal_floor). <br>
// If `$width` set in `gc`, width will generated with considering
// different gutters on breakpoints. Similarly like `Wgc_md`
// on `$mlu-bp-lg`.
// $bp = $mlu-bp-xs - breakpoint on which `$width` will sets. Can be number or breakpoint name.
// $cols = $mlu-grid-default-cols - columns count in grid. Can be number or breakpoint name.
// $calc = false - bool flag for generation CSS `calc()` fallback. It can needed only if
// $width set in 'gc' unit.
// $type = "width" - service argument which used only by mixins-wrappers.
// It needed for reusable `mlu-W` for generating grid offset,
// because the algorithm for generating them is the same.
//
// Styleguide: sass-tools.mixins.w

@mixin mlu-W($width, $bp: $mlu-bp-xs, $cols: $mlu-grid-default-cols, $gutters: $mlu-grid-gutters, $calc: false, $type: "width") {
	$col-width: 0;
	$columns: $cols;
	$grid-gutters: $gutters;
	$xs-gutter: false;
	$calc-fallback: $calc;
	$custom-unit: "";

	@if type-of($cols) == "string" {
		$columns: mlu-grid-cols-count($cols);
	} @else if type-of($cols) != "number" {
		@error "Invalid value of argument $cols: '#{$cols}'. Expected number value or breakpoint name";
	}

	@if type-of($width) == "number" and
		(unitless($width) or unit($width) == "gc" or unit($width) == "gs") {
		$tmp-val: mlu-ston($width + "");
		$col-width: mlu-decimal-floor($tmp-val / $columns * 100%, 3);
		$custom-unit: if(unit($width) == "gs", "gs", "gc");
	} @else if type-of($width) == "number" or $width == "auto" {
		$col-width: $width;
	} @else if type-of($width) != "number" {
		@error "Invalid value of argument $width: '#{$width}'. Expected number value or 'auto'";
	}

	@if type-of($gutters) == "number" {
		$grid-gutters: (if($bp == $mlu-bp-xs, $mlu-bp-sm, $bp): $gutters);
	} @else if type-of($gutters) == "map" {
		$xs-gutter: map-get($gutters, $mlu-bp-xs);
	} @else {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'number' or 'map'";
	}

	@if $bp == $mlu-bp-xs {
		$prev-gutter: if($xs-gutter, $xs-gutter, $mlu-gtr-sm);
		@include _mlu-make-width($col-width, $custom-unit, $prev-gutter, $calc-fallback, $type);
		$calc-fallback: false;

		// Repeat generation utility with new gutter if it changed on breakpoint.
		// It need for utilities for smaller breakpoints correct work
		// on larger breakpoints with changed gutter
		@each $key, $value in $grid-gutters {
			@if $value != $prev-gutter and $custom-unit == "gc" {
				@include mlu-bpm($key) {
					@include _mlu-make-width($col-width, $custom-unit, $value, $calc-fallback, $type);
				}
			}

			$prev-gutter: $value;
		}
	} @else if $custom-unit == "gc" {
		@if not map-has-key($grid-gutters, $bp) {
			$grid-gutters: map-merge($grid-gutters, ($bp: nth(nth($grid-gutters, length($grid-gutters)), 2)));
		}

		$col-gutter: map-get($grid-gutters, $bp);
		$prev-gutter: $col-gutter;

		@each $key, $value in $grid-gutters {
			// Repeat generation utility with new gutter if it changed on breakpoint.
			@if $key == $bp or ($value > $col-gutter and $value != $prev-gutter) {
				@include mlu-bpm($key) {
					@include _mlu-make-width($col-width, $custom-unit, $value, $calc-fallback, $type);
					$calc-fallback: false;
				}

				$prev-gutter: $value;
			}
		}
	} @else {
		@include mlu-bpm($bp) {
			@include _mlu-make-width($col-width, $custom-unit, $prop: $type);
		}
	}
}

// mlu-Ml
//
// Set `margin-left` on different breakpoints.
// It works similarly like [Ml utility](section-core-utils.html#kssref-core-utils-margin-ml).
//
// It wrapper on [mlu-W](#kssref-sass-tools-mixins-w) because calculating and generation algorithm
// for grid columns width and grid offsets the same. <br>
// All parameters are the same as in `mlu-W`. Only the first parameter is called `$offset`.
// ```scss
//.block {
//		@include mlu-Ml(1, "sm");
//		@include mlu-Ml(4gs, "lg");
//}
// ```
// CSS
// ```css
//@media (min-width: 520px) {
//		.block {
//			margin-left: calc(8.333% + 12px);
//		}
//}
//
//@media (min-width: 960px) {
//		.block {
//			margin-left: calc(8.333% + 16px);
//		}
//
//		.block {
//			margin-left: 33.333%;
//		}
//}
// ```
//
// $offset - can be in grid-columns(unitless number, or `gc` unit), grid-spans(`gs`),
// any CSS units(`px`, `rem` etc) or `auto`.
//
// Styleguide: sass-tools.mixins.ml

@mixin mlu-Ml($offset, $bp: $mlu-bp-xs, $cols: $mlu-grid-default-cols, $gutters: $mlu-grid-gutters, $calc: false) {
	@include mlu-W($offset, $bp, $cols, $gutters, $calc, "margin-left");
}

// Private mixin for width and grid offset generation from 'mlu-W'.

@mixin _mlu-make-width($width, $unit, $gutter: $mlu-gtr-sm, $calc: false, $prop: "width") {
	$calc-val: calc(#{$width} - #{$gutter * 2});
	$width-fallback: if($calc, mlu-decimal-floor($width, 2) - ($mlu-grid-gutter-fallback * 2), 0);

	@if $prop == "margin-left" {
		$calc-val: calc(#{$width} + #{$gutter});
		$width-fallback: if($calc, mlu-decimal-floor($width, 2) + $mlu-grid-gutter-fallback, 0);
	}

	// Generation calc() fallback
	@if $calc and $unit == "gc" {
		#{$prop}: $width-fallback;
	}

	@if $unit == "gc" {
		#{$prop}: $calc-val;
	} @else {
		#{$prop}: $width;
	}
}

// mlu-row
//
// Generate [row](section-core-blocks.html#kssref-core-blocks-row) block styles.
// ```scss
//.block {
//		@include mlu-row;
//}
// ```
//
// $display = block - display type. Can be value of CSS `display` property.
//
// Styleguide: sass-tools.mixins.row

@mixin mlu-row($display: block) {
	position: relative;
	display: $display;
	margin: 0px;
	padding: 0px;
	font-size: 0px;
	list-style: none;
	counter-reset: mlu-row-item;
}

// mlu-row-col
//
// Generate styles for [row__col](section-core-blocks.html#kssref-core-blocks-row-row__col) element.
// ```scss
//.item {
//		@include mlu-row-col;
//}
// ```
//
// $display = inline-block - display type. Can be value of CSS `display` property.
// $gutters = $mlu-grid-gutters - map with column gutters values on breakpoints.
// $calc = false - bool flag for generation CSS `calc()` fallback. It can needed only
// for "col" `$type`.
// $type = "col" - service parameter which used only by mixins-wrappers.
// It needed for reusable `mlu-row-col` for making other
// `row` elements, because the most of styles for them is the same.
//
// Styleguide: sass-tools.mixins.row_col

@mixin mlu-row-col($display: inline-block, $gutters: $mlu-grid-gutters, $calc: false, $type: "col") {
	$grid-gutters: $gutters;
	$xs-gutter: $mlu-gtr-sm;

	@if type-of($gutters) == "number" {
		$grid-gutters: ($mlu-bp-xs: $gutters);
	} @else if type-of($gutters) == "map" {
		$xs-gutter: if(map-has-key($gutters, $mlu-bp-xs), map-get($gutters, $mlu-bp-xs), $xs-gutter);
	} @else {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'number' or 'map'";
	}

	$init-gutter: if($xs-gutter == map-get($grid-gutters, $mlu-bp-sm), -1, false);

	position: relative;
	display: $display;
	max-width: 100%;
	box-sizing: border-box;
	font-size: $mlu-base-font-size;
	font-size: mlu-px2rem($mlu-base-font-size);
	text-align: left;
	vertical-align: top;
	direction: ltr;

	@if $type == "col" {
		@if $calc {
			width: 100% - ($mlu-grid-gutter-fallback * 2);
			margin: 0 $mlu-grid-gutter-fallback $xs-gutter * 2;
		}

		width: calc(100% - #{$xs-gutter * 2});
		$tmp-gtr: if($calc, calc(#{$xs-gutter}), $xs-gutter);
		margin: 0 $tmp-gtr $xs-gutter * 2;
		@include mlu-generate-gutter($init-gutter, $gutters: $grid-gutters, $calc: $calc);
		@include mlu-generate-gutter($init-gutter, $gutters: $grid-gutters, $direct: "bottom", $coef: 2);

		&.row {
			margin-bottom: 0px;
			font-size: 0px;
		}
	} @else {
		&.row {
			font-size: 0px;
		}
	}

	& > :first-child:not([class]) {
		margin-top: 0px;
	}

	& > :last-child:not([class]) {
		margin-bottom: 0px;
	}
}

// mlu-row-item
//
// Generate styles for [row__item](section-core-blocks.html#kssref-core-blocks-row-row__item) element.
//
// It mixin-wrapper on `mlu-row-col` because most of styles the same.
// ```scss
//.item {
//		@include mlu-row-item;
//}
// ```
//
// $display = inline-block - display type. Can be value of CSS `display` property.
//
// Styleguide: sass-tools.mixins.row_item

@mixin mlu-row-item($display: inline-block) {
	@include mlu-row-col($display, $type: "item");
}
