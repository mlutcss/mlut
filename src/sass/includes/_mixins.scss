/// bpm - breakpoint manager

/// $from and $to is breakpoints. They can be keyword (string) or number.
/// $from generate to 'min-width' mediaquery, and $to to 'max-width' - 1.
/// Together they generate to 'min-width and max-width - 1'.

/// In $opt you can pass string with additional features or device to check.
/// For example:
/// '(orientation: landscape)',
/// 'screen and (aspect-ratio: 11/5)',
/// 'print'.

/// $prop is property in mediaquery. Property generate like '#{$type}-#{$prop}',
/// where $type can be 'min' or 'max'. By default $prop is 'width'.
/// $type depends on availability $from and $to

@mixin mlu-bpm($from: false, $to: false, $opt: false, $prop: "width") {
	$type: "min";
	$bp-val: ();

	@if $from and $to {
		$type: "range";
	} @else if $to {
		$type: "max";
	} @else if not $from {
		@error "Breakpoint value must be not null.";
	}

	@each $item in ($from, $to) {
		@if type-of($item) == "string" {
			$bp-val: append($bp-val,
			if($item == $to,
			mlu-breakpoint($item) - 1,
			mlu-breakpoint($item)));
		} @else if type-of($item) == "number" and not unitless($item) {
			$item-to: $item;

			@if unit($item) == "em" {
				$item-to: mlu-px2em((($item / 1em) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "rem" {
				$item-to: mlu-px2rem((($item / 1rem) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "px" {
				$item-to: $item - 1;
			}

			$bp-val: append($bp-val,
			if($item == $to, $item-to, $item));
		} @else if type-of($item) != "bool" or (type-of($item) == "bool" and $item) {
			@error "Invalid breakpoint type: '#{type-of($item)}' or value: '#{$item}'";
		}
	}

	$opt: if($opt, $opt + " ", "");
	$media-str: "";

	@if $type == "range" {
		$media-str: $opt + "(min-" + $prop + ":" + nth($bp-val, 1) + ") and (max-" + $prop + ":" + nth($bp-val, 2) + ")";
	} @else {
		$bp-val: nth($bp-val, 1);
		$media-str: $opt + "(" + $type + "-" + $prop + ":" + $bp-val + ")";
	}

	@media #{$media-str} {
		@content;
	}
}

/// Generator BEM modifiers for block with icon.

/// $sprite is map with icons data.
/// Icon rendered as a $pseudo element. Default is 'before'

/// $sprite examples

/// Map with 4 parameters of icon data list:
/// $icons: (
///		modifier-name: (width, height, bgpx, bgpy),
///		car: (208px, 90px, -767px, -5px),
///	);

/// If icons have the same sizes you can write in map only 2 params:
/// $icons: (
///		modifier-name: (bgpx, bgpy),
///		car: (-767px, -5px),
///	);
///
/// All icon data lists must be equal length

/// If one or some parameters the same in all icons, it will not be
/// generated in modifiers that DRY. Write repeating
/// parameter in block class.

// .block {
//		@include mlu-mods-from-sprite($icons);
//	}

@mixin mlu-mods-from-sprite($sprite, $pseudo: "before") {
	@if type-of($sprite) != "map" {
		@error "Wrong type of argument $sprite: '#{type-of($sprite)}'. Expected 'map'";
	}

	$diff-prop-flags: (false, false, false, false);
	$icons-data-list: map-values($sprite);

	@each $value in $icons-data-list {
		$i: index($icons-data-list, $value);

		@if $i > 1 {
			$prev-value: nth($icons-data-list, $i - 1);

			@if length($value) != length($prev-value) {
				@error "Invalid format of sprite item data: all icons data lists must have equal count of parameters";
			}

			@for $j from 1 through length($value) {
				@if nth($value, $j) != nth($prev-value, $j) {
					$diff-prop-flags: set-nth($diff-prop-flags, $j, 1);
				}
			}
		}
	}

	@each $key, $value in $sprite {
		$val-length: length($value);

		@at-root {
			&--#{$key}:#{$pseudo} {
				@if $val-length == 4 {
					@if nth($diff-prop-flags, 1) {
						width: nth($value, 1);
					}

					@if nth($diff-prop-flags, 2) {
						height: nth($value, 2);
					}
				} @else if $val-length != 2 {
					@error "Invalid format of sprite item data: '(#{$value})'. Expected 2 or 4 parameters";
				}

				@if nth($diff-prop-flags, $val-length - 1) and nth($diff-prop-flags, $val-length) {
					background-position: nth($value, $val-length - 1) nth($value, $val-length);
				} @else if nth($diff-prop-flags, $val-length - 1) {
					background-position-x: nth($value, $val-length - 1);
				} @else if nth($diff-prop-flags, $val-length) {
					background-position-y: nth($value, $val-length);
				}
			}
		}
	}
}

/// simple hover wich change color
/// to lighter on hover and darker on active

/// $color is init color that will change.

/// $prop is CSS property that will change. Default is background-color

/// $lighten is percent on which the $color will become lighten
/// with sass function 'lighten' on :hover.

/// $darken is the same at $lighten but $color will change
/// on :active

// .btn--common {
//		@include mlu-def-hover(#f00);
// }

@mixin mlu-def-hover($color, $prop: "bgc", $lighten: 8%, $darken: ($lighten - 3)) {
	$prop: if($prop == "bgc", "background-color", $prop);

	&:hover,
	&:focus {
		#{$prop}: lighten($color, $lighten);
	}

	&:active {
		#{$prop}: darken($color, $darken);
	}
}

/// Generate clearfix for float layout
@mixin mlu-clearfix {
	&:after {
		display: table;
		clear: both;
		content: "";
	}
}

/// Generate grid gutter on different breakpoints.

/// Gutter $type can be margin or padding in different directions.

/// $direct can take 4 main directions from $mlu-main-directions
/// or combined direction - 'x'(left right), 'y'(top bottom)
/// and 'xy'(left right top bottom).

/// You can pass map with custom gutters value in $gutters.

/// $calc is fallback for old browsers. It need if your cols work this calc() width.

/// $coef is coefficient by which the gutter value is multiplied

@mixin mlu-generate-gutter($init-gutter: $mlu-gtr-sm, $type: "margin",
$gutters: $mlu-grid-gutters, $calc: false, $direct: "x", $coef: 1) {
	@if not ($type == "margin" or $type == "padding") {
		@error "Invalid gutter type - '#{$type}'! Allowable margin or padding";
	}

	@if type-of($gutters) != "map" {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'map'";
	}

	$prev-value: if(map-has-key($gutters, $mlu-bp-xs), map-get($gutters, $mlu-bp-xs), $init-gutter);

	@if $init-gutter and $init-gutter != -1 {
		$tmp-val: if($calc, calc(#{$prev-value * $coef}), $prev-value * $coef);

		@if $direct == "x" {
			#{$type}: 0px ($mlu-grid-gutter-fallback * $coef);
			#{$type}: 0px $tmp-val;
		} @else if $direct == "y" {
			#{$type}: ($mlu-grid-gutter-fallback * $coef) 0px;
			#{$type}: $tmp-val 0px;
		} @else if $direct == "xy" {
			#{$type}: ($mlu-grid-gutter-fallback * $coef);
			#{$type}: $tmp-val;
		} @else if index($mlu-main-directions, $direct) {
			#{$type}-#{$direct}: $tmp-val;
		} @else {
			@error "Invalid gutter direction - '#{$direct}'";
		}
	}

	@each $key, $value in $gutters {
		$cur-val: if($prev-value and unit($prev-value) == "rem", mlu-px2rem($value), $value);

		@if $prev-value != -1 and $cur-val != $prev-value {
			@include mlu-bpm($key) {
				$tmp-val: if($calc, calc(#{$cur-val * $coef}), $cur-val * $coef);

				@if $direct == "x" {
					#{$type}-left: $tmp-val;
					#{$type}-right: $tmp-val;
				} @else if $direct == "y" {
					#{$type}-top: $tmp-val;
					#{$type}-bottom: $tmp-val;
				} @else if $direct == "xy" {
					#{$type}: $tmp-val;
				} @else if index($mlu-main-directions, $direct) {
					#{$type}-#{$direct}: $tmp-val;
				} @else {
					@error "Invalid gutter direction - '#{$direct}'";
				}
			}
		}

		$prev-value: $cur-val;
	}
}

/// Generate block with icon form css-$sprite in $pseudo element.
/// $sprite is path to css-sprite in png.
/// $pseudo is type of pseudo element: before or after.

// .icon {
//		@include mlu-icon() {
//			width: 32px
//		};
// }

@mixin mlu-icon($sprite: "../img/css_sprites.png", $pseudo: "before") {
	position: relative;

	&:#{$pseudo} {
		position: absolute;
		background-image: url($sprite);
		background-repeat: no-repeat;
		content: "";

		@content;
	}
}

/// Generate circle

/// $diametr is circle diametr.

/// $bgc is circle background-color.

@mixin mlu-circle($diametr, $bgc: transparent) {
	width: $diametr;
	height: $diametr;
	background-color: $bgc;
	border-radius: 50%;
}

/// Generate blank for border triangle.

/// $size is triangle size.
/// For create triangle you need to add border-color for one of side
/// after this mixin.
/// For example:
/// border-top-color: #f00

@mixin mlu-triangle($size) {
	width: 0px;
	height: 0px;
	border: $size transparent solid;
}

/// Generate rhomb with CSS linear-gradient() in background-image.

/// $edge-ang is linear-gradient angle of rhomb edges. Can be only number in deg.

/// $edge-cs is color stop in linear-gradient of rhomb edges. Can be number with unit.

/// $bgc is rhomb color. It can be single color or list in linear-gradient
/// value format. For example:
/// $bgc: (167deg, blue 50%, #f0f, #000)
/// Angle in gradient can be only number in deg. If you pass gradient value
/// top rhomb edge get first color, bottom edge get last color and
/// rhomb body get full gradient.

/// $body-size is background-size of linear-gradient of rhomb body.

/// If you already generated rhomb and want to change their color
/// pass to $change '1'. You also can change $body-size with $change turned on

// .block {
//		&:before {
//			mlu-bgi-rhomb($bgc);
//		}
//	}

@mixin mlu-bgi-rhomb($edge-ang: 150deg, $edge-cs: 50%, $bgc: #000,
$body-size: (100% 48%), $change: false) {

	@if not (type-of($edge-ang) == "number" and unit($edge-ang) == "deg") {
		@error "Invalid value of argument $edge-and - '#{$edge-ang}'. Expected angle in deg.";
	}

	$first-color: $bgc;
	$last-color: $first-color;
	$body-gradient: ($bgc, $bgc);
	$edge-ang-bot: $edge-ang + 180;

	@if type-of($bgc) == "list" {
		$first-color: nth(nth($bgc, 1), 1);
		$val-type: type-of($first-color);

		@if $val-type == "number" and unit($first-color) == "deg" {
			$first-color: nth(nth($bgc, 2), 1);
		} @else if $val-type != "color" or ($val-type == "number" and unitless(nth($bgc, 1))) {
			@error "Invalid gradient format: first value can be angle in deg or color but now value is '#{$first-color}'";
		}

		$last-color: nth(nth($bgc, length($bgc)), 1);
		$body-gradient: $bgc;
	} @else if type-of($bgc) != "color" {
		@error "Wrong type of argument $bgc: '#{type-of($bgc)}'. Expected 'color' or 'list'";
	}

	@if not $change {
		box-sizing: border-box;
		background-repeat: no-repeat;
		background-position: 0px 0px, 100% 0px, 50% 50%, 0px 102%, 100% 102%;
	}

	@if not $change or $body-size != (100% 48%) {
		background-size: 51% 27%, 51% 27%, $body-size, 51% 28%, 51% 28%;
	}

	background-image: linear-gradient($edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient(-$edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient($body-gradient),
		linear-gradient(-$edge-ang-bot, transparent $edge-cs, $last-color $edge-cs),
		linear-gradient($edge-ang-bot, transparent $edge-cs, $last-color $edge-cs);
}

/// Restore default browser outline on focus state

@mixin mlu-restore-outline {
	&:focus {
		outline: 1px dotted #212121;
		outline: -webkit-focus-ring-color auto 5px;
	}
}

/// Set $width in grid columns, grid spans or CSS units on different breakpoints.
/// It works similarly like W utility.

/// $width can be in grid columns(unitless number, or 'gc' unit), grid spans('gs'),
/// any CSS units('px', 'rem' etc) or 'auto'. Grid units calculated to %
/// according to the formula 'n / $cols * 100%' and rounded by
/// 'mlu-decimal-floor'.

/// If $width set in 'gc' or unitless, width will generated with considering
/// different gutters on breakpoints. Similarly like Wgc_md utility
/// on $mlu-bp-lg.

/// $bp is breakpoint on which $width will sets.

/// $cols is columns count in grid.

/// $calc is flag for generation CSS 'calc()' fallback. It only needed if
/// $width set in 'gc' unit.

/// $type is service argument which used only by mixins-wrappers.
/// It needed for reusable mlu-W for generating grid offset,
/// because the algorithm for generating them is the same.

// .block {
//		@include mlu-W(2, sm);
//		@include mlu-W(4, md);
//}

@mixin mlu-W($width, $bp: $mlu-bp-xs, $cols: $mlu-grid-default-cols, $gutters: $mlu-grid-gutters, $calc: false, $type: "width") {
	$col-width: 0;
	$columns: $cols;
	$grid-gutters: $gutters;
	$xs-gutter: false;
	$calc-fallback: $calc;
	$custom-unit: "";

	@if type-of($cols) == "string" {
		$columns: mlu-grid-cols-count($cols);
	} @else if type-of($cols) != "number" {
		@error "Invalid value of argument $cols: '#{$cols}'. Expected number value or breakpoint name";
	}

	@if type-of($width) == "number" and
		(unitless($width) or unit($width) == "gc" or unit($width) == "gs") {
		$tmp-val: mlu-ston($width + "");
		$col-width: mlu-decimal-floor($tmp-val / $columns * 100%, 3);
		$custom-unit: if(unit($width) == "gs", "gs", "gc");
	} @else if type-of($width) == "number" or $width == "auto" {
		$col-width: $width;
	} @else if type-of($width) != "number" {
		@error "Invalid value of argument $width: '#{$width}'. Expected number value or 'auto'";
	}

	@if type-of($gutters) == "number" {
		$grid-gutters: (if($bp == $mlu-bp-xs, $mlu-bp-sm, $bp): $gutters);
	} @else if type-of($gutters) == "map" {
		$xs-gutter: map-get($gutters, $mlu-bp-xs);
	} @else {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'number' or 'map'";
	}

	@if $bp == $mlu-bp-xs {
		$prev-gutter: if($xs-gutter, $xs-gutter, $mlu-gtr-sm);
		@include mlut-make-width($col-width, $custom-unit, $prev-gutter, $calc-fallback, $type);
		$calc-fallback: false;

		@each $key, $value in $grid-gutters {
			@if $value != $prev-gutter and $custom-unit == "gc" {
				@include mlu-bpm($key) {
					@include mlut-make-width($col-width, $custom-unit, $value, $calc-fallback, $type);
				}
			}

			$prev-gutter: $value;
		}
	} @else if $custom-unit == "gc" {
		@if not map-has-key($grid-gutters, $bp) {
			$grid-gutters: map-merge($grid-gutters, ($bp: nth(nth($grid-gutters, length($grid-gutters)), 2)));
		}

		$col-gutter: map-get($grid-gutters, $bp);
		$prev-gutter: $col-gutter;

		@each $key, $value in $grid-gutters {
			@if $key == $bp or ($value > $col-gutter and $value != $prev-gutter) {
				@include mlu-bpm($key) {
					@include mlut-make-width($col-width, $custom-unit, $value, $calc-fallback, $type);
					$calc-fallback: false;
				}

				$prev-gutter: $value;
			}
		}
	} @else {
		@include mlu-bpm($bp) {
			@include mlut-make-width($col-width, $custom-unit, $prop: $type);
		}
	}
}

/// Set $offset in grid columns, grid spans or CSS units on different breakpoints.

/// It wrapper on 'mlu-W' because calculating and generation algorithm of
/// width for grid columns width and grid offsets the same

@mixin mlu-Ml($offset, $bp: $mlu-bp-xs, $cols: $mlu-grid-default-cols, $calc: false) {
	@include mlu-W($offset, $bp, $cols, $calc, "margin-left");
}

/// Private mixin for width and grid offset generation from 'mlu-W'.

@mixin mlut-make-width($width, $unit, $gutter: $mlu-gtr-sm, $calc: false, $prop: "width") {
	$calc-val: calc(#{$width} - #{$gutter * 2});
	$width-fallback: if($calc, mlu-decimal-floor($width, 2) - ($mlu-grid-gutter-fallback * 2), 0);

	@if $prop == "margin-left" {
		$calc-val: calc(#{$width} + #{$gutter});
		$width-fallback: if($calc, mlu-decimal-floor($width, 2) + $mlu-grid-gutter-fallback, 0);
	}

	@if $calc and $unit == "gc" {
		#{$prop}: $width-fallback;
	}

	@if $unit == "gc" {
		#{$prop}: $calc-val;
	} @else {
		#{$prop}: $width;
	}
}

/// Generate styles for 'row' block.

/// $display is display type

@mixin mlu-row($display: block) {
	position: relative;
	display: $display;
	margin: 0px;
	padding: 0px;
	font-size: 0px;
	list-style: none;
	counter-reset: mlu-row-item;
}

/// Generate styles for 'row' elements like 'row__col', 'row__cell' etc.

/// $display is display type.

/// $calc is flag for generation CSS 'calc()' fallback. It only needed if
/// for "col" $type.

/// $type is service argument which used only by mixins-wrappers.
/// It needed for reusable mlu-row-col for making other,
/// 'row' elements because the most of styles for them is the same.

@mixin mlu-row-col($display: inline-block, $gutters: $mlu-grid-gutters, $calc: false, $type: "col") {
	$grid-gutters: $gutters;
	$xs-gutter: $mlu-gtr-sm;

	@if type-of($gutters) == "number" {
		$grid-gutters: ($mlu-bp-xs: $gutters);
	} @else if type-of($gutters) == "map" {
		$xs-gutter: if(map-has-key($gutters, $mlu-bp-xs), map-get($gutters, $mlu-bp-xs), $xs-gutter);
	} @else {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'number' or 'map'";
	}

	$init-gutter: if($xs-gutter == map-get($grid-gutters, $mlu-bp-sm), -1, false);

	position: relative;
	display: $display;
	max-width: 100%;
	box-sizing: border-box;
	text-align: left;
	vertical-align: top;
	font-size: $mlu-base-font-size;
	font-size: mlu-px2rem($mlu-base-font-size);
	direction: ltr;

	@if $type == "col" {
		@if $calc {
			width: 100% - ($mlu-grid-gutter-fallback * 2);
			margin: 0 $mlu-grid-gutter-fallback $xs-gutter * 2;
		}

		width: calc(100% - #{$xs-gutter * 2});
		$tmp-gtr: if($calc, calc(#{$xs-gutter}), $xs-gutter);
		margin: 0 $tmp-gtr $xs-gutter * 2;
		@include mlu-generate-gutter($init-gutter, $gutters: $grid-gutters, $calc: $calc);
		@include mlu-generate-gutter($init-gutter, $gutters: $grid-gutters, $direct: "bottom", $coef: 2);

		&.row {
			margin-bottom: 0px;
			font-size: 0px;
		}
	} @else {
		@if $type == "cell" {
			width: 100%;
			@include mlu-generate-gutter($gutters: $grid-gutters, $type: "padding");
		}

		&.row {
			font-size: 0px;
		}
	}

	& > :first-child:not([class]) {
		margin-top: 0px;
	}

	& > :last-child:not([class]) {
		margin-bottom: 0px;
	}
}

/// Generate styles for 'row__cell' element.

/// It mixin-wrapper on 'mlu-row-col' because most of styles the same.

@mixin mlu-row-cell($display: inline-block, $gutters: $mlu-grid-gutters) {
	@include mlu-row-col($display, $gutters, $type: "cell");
}

/// Generate styles for 'row__item' element.

/// It mixin-wrapper on 'mlu-row-col' because most of styles the same.

@mixin mlu-row-item($display: inline-block) {
	@include mlu-row-col($display, $type: "item");
}
