/// bpm - breakpoint manager

/// $from and $to is breakpoints. They can be keyword (string) or number.
/// $from generate to 'min-width' mediaquery, and $to to 'max-width' - 1.
/// Together they generate to 'min-width and max-width - 1'.

/// In $opt you can pass string with additional features or device to check.
/// For example:
/// '(orientation: landscape)',
/// 'screen and (aspect-ratio: 11/5)',
/// 'print'.

/// $prop is property in mediaquery. Property generate like '#{$type}-#{$prop}',
/// where $type can be 'min' or 'max'. By default $prop is 'width'.
/// $type depends on availability $from and $to

@mixin mlu-bpm($from: false, $to: false, $opt: false, $prop: "width") {
	$type: "min";
	$bp-val: ();

	@if $from and $to {
		$type: "range";
	} @else if $to {
		$type: "max";
	} @else if not $from {
		@error "Breakpoint value must be not null.";
	}

	@each $item in ($from, $to) {
		@if type-of($item) == "string" {
			$bp-val: append($bp-val,
			if($item == $to,
			mlu-breakpoint($item) - 1,
			mlu-breakpoint($item)));
		} @else if type-of($item) == "number" and not unitless($item) {
			$item-to: $item;

			@if unit($item) == "em" {
				$item-to: mlu-px2em((($item / 1em) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "rem" {
				$item-to: mlu-px2rem((($item / 1rem) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "px" {
				$item-to: $item - 1;
			}

			$bp-val: append($bp-val,
			if($item == $to, $item-to, $item));
		} @else if type-of($item) != "bool" or (type-of($item) == "bool" and $item) {
			@error "Invalid breakpoint type - '#{type-of($item)}' or value - '#{$item}'";
		}
	}

	$opt: if($opt, $opt + " ", "");
	$media-str: "";

	@if $type == "range" {
		$media-str: $opt + "(min-" + $prop + ":" + nth($bp-val, 1) + ") and (max-" + $prop + ":" + nth($bp-val, 2) + ")";
	} @else {
		$bp-val: nth($bp-val, 1);
		$media-str: $opt + "(" + $type + "-" + $prop + ":" + $bp-val + ")";
	}

	@media #{$media-str} {
		@content;
	}
}

/// Generator BEM modifiers for block with icon.

/// $sprite is map with icons data.
/// Icon rendered as a $pseudo element. Default is 'before'

/// $sprite example
/// $icons: (
///		modifier-name: (width, height, bgpx, bgpy),
///		car: (208px, 90px, -767px, -5px),
///	);

@mixin mlu-mods-from-sprite($sprite, $pseudo: "before") {
	@if type-of($sprite) == "map" {
		@at-root {
			@each $key, $value in $sprite {
				&--#{$key}:#{$pseudo} {
					width: nth($value, 1);
					height: nth($value, 2);
					background-position: nth($value, 3) nth($value, 4);
				}
			}
		}
	} @else {
		@error "Sprite isn't map but a '#{type-of($sprite)}'";
	}
}

/// simple hover wich change color
/// to lighter on hover and darker on active

/// $color is init color that will change.
/// $prop is CSS property that will change. Default is background-color

/// $lighten is percent on which the $color will become lighten
/// with sass function 'lighten' on :hover.

/// $darken is the same at $lighten but $color will change
/// on :active

@mixin mlu-def-hover($color, $prop: "bgc", $lighten: 8%, $darken: ($lighten - 3)) {
	$prop: if($prop == "bgc", "background-color", $prop);

	&:hover,
	&:focus {
		#{$prop}: lighten($color, $lighten);
	}

	&:active {
		#{$prop}: darken($color, $darken);
	}
}

/// Generate clearfix for float layout
@mixin clearfix {
	&:after {
		display: table;
		content: "";
		clear: both;
	}
}

/// Generate grid gutter on different breakpoints.

/// Gutter $type can be margin or padding in different directions.
/// $direct can take 4 main directions from $mlu-main-directions
/// or combined direction - 'x'(left right), 'y'(top bottom)
/// and 'xy'(left right top bottom).
/// You can pass map with custom gutters value in $gutters.
/// $calc is fallback for old browsers. It need if your cols work this calc() width.
/// $coef is coefficient by which the gutter value is multiplied

@mixin mlu-generate-gutter($init-gutter: $mlu-gtr-sm, $type: "margin",
$gutters: $mlu-grid-gutters, $calc: false, $direct: "x", $coef: 1) {
	$prev-value: $init-gutter;

	@if not ($type == "margin" or $type == "padding") {
		@error "Invalid gutter type - '#{$type}'! Allowable margin or padding";
	}

	@if $init-gutter and $init-gutter != -1 {
		$tmp-val: if($calc, calc(#{$init-gutter * $coef}), $init-gutter * $coef);

		@if $direct == "x" {
			#{$type}: 0px ($mlu-grid-gutter-fallback * $coef);
			#{$type}: 0px $tmp-val;
		} @else if $direct == "y" {
			#{$type}: ($mlu-grid-gutter-fallback * $coef) 0px;
			#{$type}: $tmp-val 0px;
		} @else if $direct == "xy" {
			#{$type}: ($mlu-grid-gutter-fallback * $coef);
			#{$type}: $tmp-val;
		} @else if index($mlu-main-directions, $direct) {
			#{$type}-#{$direct}: $tmp-val;
		} @else {
			@error "Invalid gutter direction - '#{$direct}'";
		}
	}

	@each $key, $value in $gutters {
		$cur-val: if(unit($init-gutter) == "rem", mlu-px2rem($value), $value);

		@if $prev-value != -1 and $cur-val != $prev-value {
			@include mlu-bpm($key) {
				$tmp-val: if($calc, calc(#{$cur-val * $coef}), $cur-val * $coef);

				@if $direct == "x" {
					#{$type}-left: $tmp-val;
					#{$type}-right: $tmp-val;
				} @else if $direct == "y" {
					#{$type}-top: $tmp-val;
					#{$type}-bottom: $tmp-val;
				} @else if $direct == "xy" {
					#{$type}: $tmp-val;
				} @else if index($mlu-main-directions, $direct) {
					#{$type}-#{$direct}: $tmp-val;
				} @else {
					@error "Invalid gutter direction - '#{$direct}'";
				}
			}
		}

		$prev-value: $cur-val;
	}
}

/// Generate block with icon form css-$sprite in $pseudo element.
/// $sprite is path to css-sprite in png.
/// $pseudo is type of pseudo element: before or after.

@mixin mlu-icon($sprite: "../img/css_sprites.png", $pseudo: "before") {
	position: relative;

	&:#{$pseudo} {
		position: absolute;
		background-image: url($sprite);
		background-repeat: no-repeat;
		content: "";

		@content;
	}
}

/// Generate circle

/// $diametr is circle diametr.
/// $bgc is circle background-color.

@mixin mlu-circle($diametr, $bgc: transparent) {
	width: $diametr;
	height: $diametr;
	background-color: $bgc;
	border-radius: 50%;
}

/// Generate blank for border triangle.

/// $size is triangle size.
/// For create triangle you need to add border-color for one of side
/// after this mixin.
/// For example:
/// border-top-color: #f00

@mixin mlu-triangle($size) {
	width: 0px;
	height: 0px;
	border: $size transparent solid;
}

/// Generate rhomb with css linear-gradient() in background-image.

/// $edge-ang is linear-gradient angle of rhomb edges; Can be only number in deg.

/// $edge-cs is color stop in linear-gradient of rhomb edges; Can be number with unit.

/// $bgc is rhomb color; It can be single color or list in linear-gradient
/// value format; For example:
/// $bgc: (167deg, blue 50%, #f0f, #000)
/// Angle in gradient can be only number in deg; If you pass gradient value
/// top rhomb edge get first color, bottom edge get last color and
/// rhomb body get full gradient.

/// $body-size is background-size of linear-gradient of rhomb body.

/// If you already generated rhomb and want to change their color
/// pass to $change '1'; You also can change $body-size with $change turned on

@mixin mlu-bgi-rhomb($edge-ang: 150deg, $edge-cs: 50%, $bgc: #000,
$body-size: (100% 48%), $change: false) {

	@if not (type-of($edge-ang) == "number" and unit($edge-ang) == "deg") {
		@error "Invalid value of argument $edge-and - '#{$edge-ang}'. Expected angle in deg.";
	}

	$first-color: $bgc;
	$last-color: $first-color;
	$body-gradient: ($bgc, $bgc);
	$edge-ang-bot: $edge-ang + 180;

	@if type-of($bgc) == "list" {
		$first-color: nth(nth($bgc, 1), 1);
		$val-type: type-of($first-color);

		@if $val-type == "number" and unit($first-color) == "deg" {
			$first-color: nth(nth($bgc, 2), 1);
		} @else if $val-type != "color" or ($val-type == "number" and unitless(nth($bgc, 1))) {
			@error "Invalid gradient format: first value can be angle in deg or color but now value is '#{$first-color}'";
		}

		$last-color: nth(nth($bgc, length($bgc)), 1);
		$body-gradient: $bgc;
	} @else if type-of($bgc) != "color" {
		@error "Wrong type of argument $bgc - '#{type-of($bgc)}'. Expected 'color' or 'list'";
	}

	@if not $change {
		box-sizing: border-box;
		background-repeat: no-repeat;
		background-position: 0px 0px, 100% 0px, 50% 50%, 0px 102%, 100% 102%;
	}

	@if not $change or $body-size != (100% 48%) {
		background-size: 51% 27%, 51% 27%, $body-size, 51% 28%, 51% 28%;
	}

	background-image: linear-gradient($edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient(-$edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient($body-gradient),
		linear-gradient(-$edge-ang-bot, transparent $edge-cs, $last-color $edge-cs),
		linear-gradient($edge-ang-bot, transparent $edge-cs, $last-color $edge-cs);
}

/// Restore default browser outline on focus state

@mixin mlu-restore-outline {
	&:focus {
		outline: 1px dotted #212121;
		outline: -webkit-focus-ring-color auto 5px;
	}
}
